<!DOCTYPE html><html lang="zh" class="no-js"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://0richalcos.github.io/Note/%E8%BF%90%E7%BB%B4/Docker.html"><link rel="prev" href="../%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/XXL-JOB.html"><link rel="next" href="Linux.html"><link rel="icon" href="../assets/images/favicon.png"><meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1"><title>🧑‍🔧 运维 - 随便记记</title><link rel="stylesheet" href="../assets/stylesheets/main.484c7ddc.min.css"><link rel="stylesheet" href="../assets/stylesheets/palette.ab4e12ef.min.css"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&amp;display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel="stylesheet" href="../_stylesheets/extra.css"><script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script><link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"><script src="../assets/javascripts/glightbox.min.js"></script><style id="glightbox-style">
            html.glightbox-open { overflow: initial; height: 100%; }
            .gslide-title { margin-top: 0px; user-select: text; }
            .gslide-desc { color: #666; user-select: text; }
            .gslide-image img { background: white; }
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color); }
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color); }
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color); }
        </style></head> <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="teal"> <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off"> <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off"> <label class="md-overlay" for="__drawer"></label> <div data-md-component="skip"> <a href="#1简介" class="md-skip"> 跳转至 </a> </div> <div data-md-component="announce"> </div> <header class="md-header md-header--shadow" data-md-component="header"> <nav class="md-header__inner md-grid" aria-label="页眉"> <a href="../index.html" title="随便记记" class="md-header__button md-logo" aria-label="随便记记" data-md-component="logo"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"></path></svg> </a> <label class="md-header__button md-icon" for="__drawer"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg> </label> <div class="md-header__title" data-md-component="header-title"> <div class="md-header__ellipsis"> <div class="md-header__topic"> <span class="md-ellipsis"> 随便记记 </span> </div> <div class="md-header__topic" data-md-component="header-topic"> <span class="md-ellipsis"> 🧑‍🔧 运维 </span> </div> </div> </div> <form class="md-header__option" data-md-component="palette"> <input class="md-option" data-md-color-media data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="teal" aria-label="切换到深色模式" type="radio" name="__palette" id="__palette_0"> <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"></path></svg> </label> <input class="md-option" data-md-color-media data-md-color-scheme="slate" data-md-color-primary="teal" data-md-color-accent="teal" aria-label="切换到亮色模式" type="radio" name="__palette" id="__palette_1"> <label class="md-header__button md-icon" title="切换到亮色模式" for="__palette_0" hidden> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"></path></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <div class="md-header__source"> <a href="https://github.com/0richalcos/Note" title="前往仓库" class="md-source" data-md-component="source"> <div class="md-source__icon md-icon"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!-- Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"></path></svg> </div> <div class="md-source__repository"> GitHub </div> </a> </div> </nav> </header> <div class="md-container" data-md-component="container"> <main class="md-main" data-md-component="main"> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation"> <div class="md-sidebar__scrollwrap"> <div class="md-sidebar__inner"> <nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0"> <label class="md-nav__title" for="__drawer"> <a href="../index.html" title="随便记记" class="md-nav__button md-logo" aria-label="随便记记" data-md-component="logo"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"></path></svg> </a> 随便记记 </label> <div class="md-nav__source"> <a href="https://github.com/0richalcos/Note" title="前往仓库" class="md-source" data-md-component="source"> <div class="md-source__icon md-icon"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!-- Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"></path></svg> </div> <div class="md-source__repository"> GitHub </div> </a> </div> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../index.html" class="md-nav__link"> <span class="md-ellipsis"> 🏠 首页 </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2"> <div class="md-nav__link md-nav__container"> <a href="../Java/Java.html" class="md-nav__link "> <span class="md-ellipsis"> ♨️ Java </span> </a> <label class="md-nav__link " for="__nav_2" id="__nav_2_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_2"> <span class="md-nav__icon md-icon"></span> ♨️ Java </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../Java/Java8.html" class="md-nav__link"> <span class="md-ellipsis"> Java 8 </span> </a> </li> <li class="md-nav__item"> <a href="../Java/JavaBasics.html" class="md-nav__link"> <span class="md-ellipsis"> Java 基础 </span> </a> </li> <li class="md-nav__item"> <a href="../Java/JavaCollection.html" class="md-nav__link"> <span class="md-ellipsis"> Java 集合 </span> </a> </li> <li class="md-nav__item"> <a href="../Java/JavaObject.html" class="md-nav__link"> <span class="md-ellipsis"> Java 类和对象 </span> </a> </li> <li class="md-nav__item"> <a href="../Java/JavaWeb.html" class="md-nav__link"> <span class="md-ellipsis"> JavaWeb </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3"> <div class="md-nav__link md-nav__container"> <a href="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95/Algorithm.html" class="md-nav__link "> <span class="md-ellipsis"> 🧮 数据结构及算法 </span> </a> <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_3"> <span class="md-nav__icon md-icon"></span> 🧮 数据结构及算法 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95/DesignPattern.html" class="md-nav__link"> <span class="md-ellipsis"> DesignPattern </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4"> <div class="md-nav__link md-nav__container"> <a href="../Spring/Spring.html" class="md-nav__link "> <span class="md-ellipsis"> 🍃 Spring </span> </a> <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_4"> <span class="md-nav__icon md-icon"></span> 🍃 Spring </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../Spring/SpringBoot.html" class="md-nav__link"> <span class="md-ellipsis"> SpringBoot </span> </a> </li> <li class="md-nav__item"> <a href="../Spring/SpringCloud.html" class="md-nav__link"> <span class="md-ellipsis"> SpringCloud </span> </a> </li> <li class="md-nav__item"> <a href="../Spring/SpringMVC.html" class="md-nav__link"> <span class="md-ellipsis"> SpringMVC </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5"> <div class="md-nav__link md-nav__container"> <a href="../%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/MyBatis-Plus.html" class="md-nav__link "> <span class="md-ellipsis"> 💾 持久层框架 </span> </a> <label class="md-nav__link " for="__nav_5" id="__nav_5_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_5"> <span class="md-nav__icon md-icon"></span> 💾 持久层框架 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/Mybatis.html" class="md-nav__link"> <span class="md-ellipsis"> Mybatis </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6"> <div class="md-nav__link md-nav__container"> <a href="../%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/SSO.html" class="md-nav__link "> <span class="md-ellipsis"> 🔐 认证与授权 </span> </a> <label class="md-nav__link " for="__nav_6" id="__nav_6_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_6"> <span class="md-nav__icon md-icon"></span> 🔐 认证与授权 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/Sa-Token.html" class="md-nav__link"> <span class="md-ellipsis"> Sa-Token </span> </a> </li> <li class="md-nav__item"> <a href="../%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/Shiro.html" class="md-nav__link"> <span class="md-ellipsis"> Shiro </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7"> <div class="md-nav__link md-nav__container"> <a href="../%E5%89%8D%E7%AB%AF/CSS.html" class="md-nav__link "> <span class="md-ellipsis"> 🌐 前端 </span> </a> <label class="md-nav__link " for="__nav_7" id="__nav_7_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_7"> <span class="md-nav__icon md-icon"></span> 🌐 前端 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../%E5%89%8D%E7%AB%AF/JavaScript.html" class="md-nav__link"> <span class="md-ellipsis"> JavaScript </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%89%8D%E7%AB%AF/Vue.html" class="md-nav__link"> <span class="md-ellipsis"> Vue </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%89%8D%E7%AB%AF/jQuery.html" class="md-nav__link"> <span class="md-ellipsis"> jQuery </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%89%8D%E7%AB%AF/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/Thymeleaf.html" class="md-nav__link"> <span class="md-ellipsis"> Thymeleaf </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_5"> <div class="md-nav__link md-nav__container"> <a href="../%E5%89%8D%E7%AB%AF/%E7%BB%84%E4%BB%B6%E5%BA%93/AntV-X6.html" class="md-nav__link "> <span class="md-ellipsis"> 组件库 </span> </a> <label class="md-nav__link " for="__nav_7_5" id="__nav_7_5_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_5_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_7_5"> <span class="md-nav__icon md-icon"></span> 组件库 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../%E5%89%8D%E7%AB%AF/%E7%BB%84%E4%BB%B6%E5%BA%93/ApacheECharts.html" class="md-nav__link"> <span class="md-ellipsis"> ApacheECharts </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%89%8D%E7%AB%AF/%E7%BB%84%E4%BB%B6%E5%BA%93/Axios.html" class="md-nav__link"> <span class="md-ellipsis"> Axios </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%89%8D%E7%AB%AF/%E7%BB%84%E4%BB%B6%E5%BA%93/BootstrapTable.html" class="md-nav__link"> <span class="md-ellipsis"> BootstrapTable </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%89%8D%E7%AB%AF/%E7%BB%84%E4%BB%B6%E5%BA%93/DHTMLXGantt.html" class="md-nav__link"> <span class="md-ellipsis"> DHTMLXGantt </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%89%8D%E7%AB%AF/%E7%BB%84%E4%BB%B6%E5%BA%93/Element.html" class="md-nav__link"> <span class="md-ellipsis"> Element </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%89%8D%E7%AB%AF/%E7%BB%84%E4%BB%B6%E5%BA%93/FullCalendar.html" class="md-nav__link"> <span class="md-ellipsis"> FullCalendar </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%89%8D%E7%AB%AF/%E7%BB%84%E4%BB%B6%E5%BA%93/X-editable.html" class="md-nav__link"> <span class="md-ellipsis"> X-editable </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8"> <div class="md-nav__link md-nav__container"> <a href="../%E6%95%B0%E6%8D%AE%E5%BA%93/Dameng.html" class="md-nav__link "> <span class="md-ellipsis"> 📊 数据库 </span> </a> <label class="md-nav__link " for="__nav_8" id="__nav_8_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_8"> <span class="md-nav__icon md-icon"></span> 📊 数据库 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html" class="md-nav__link"> <span class="md-ellipsis"> MySQL </span> </a> </li> <li class="md-nav__item"> <a href="../%E6%95%B0%E6%8D%AE%E5%BA%93/MySQLQuery.html" class="md-nav__link"> <span class="md-ellipsis"> MySQLQuery </span> </a> </li> <li class="md-nav__item"> <a href="../%E6%95%B0%E6%8D%AE%E5%BA%93/OceanBase.html" class="md-nav__link"> <span class="md-ellipsis"> OceanBase </span> </a> </li> <li class="md-nav__item"> <a href="../%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle.html" class="md-nav__link"> <span class="md-ellipsis"> Oracle </span> </a> </li> <li class="md-nav__item"> <a href="../%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html" class="md-nav__link"> <span class="md-ellipsis"> Redis </span> </a> </li> <li class="md-nav__item"> <a href="../%E6%95%B0%E6%8D%AE%E5%BA%93/Vastbase.html" class="md-nav__link"> <span class="md-ellipsis"> Vastbase </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="../%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/Elasticsearch.html" class="md-nav__link"> <span class="md-ellipsis"> Elasticsearch </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10"> <div class="md-nav__link md-nav__container"> <a href="../%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/FastDFS.html" class="md-nav__link "> <span class="md-ellipsis"> 📇 分布式存储 </span> </a> <label class="md-nav__link " for="__nav_10" id="__nav_10_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_10"> <span class="md-nav__icon md-icon"></span> 📇 分布式存储 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/MinIO.html" class="md-nav__link"> <span class="md-ellipsis"> MinIO </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11"> <div class="md-nav__link md-nav__container"> <a href="../%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/Encryption.html" class="md-nav__link "> <span class="md-ellipsis"> 🛰️ 网络通信 </span> </a> <label class="md-nav__link " for="__nav_11" id="__nav_11_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_11"> <span class="md-nav__icon md-icon"></span> 🛰️ 网络通信 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/HTTP.html" class="md-nav__link"> <span class="md-ellipsis"> HTTP </span> </a> </li> <li class="md-nav__item"> <a href="../%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/OpenVPN.html" class="md-nav__link"> <span class="md-ellipsis"> OpenVPN </span> </a> </li> <li class="md-nav__item"> <a href="../%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/VNC.html" class="md-nav__link"> <span class="md-ellipsis"> VNC </span> </a> </li> <li class="md-nav__item"> <a href="../%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/WebSocket.html" class="md-nav__link"> <span class="md-ellipsis"> WebSocket </span> </a> </li> <li class="md-nav__item"> <a href="../%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/frp.html" class="md-nav__link"> <span class="md-ellipsis"> frp </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12"> <label class="md-nav__link" for="__nav_12" id="__nav_12_label" tabindex="0"> <span class="md-ellipsis"> 🗃️ 文件处理 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_12"> <span class="md-nav__icon md-icon"></span> 🗃️ 文件处理 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12_1"> <div class="md-nav__link md-nav__container"> <a href="../%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/Office/ApachePOI.html" class="md-nav__link "> <span class="md-ellipsis"> Office </span> </a> <label class="md-nav__link " for="__nav_12_1" id="__nav_12_1_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_12_1_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_12_1"> <span class="md-nav__icon md-icon"></span> Office </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/Office/EasyExcel.html" class="md-nav__link"> <span class="md-ellipsis"> EasyExcel </span> </a> </li> <li class="md-nav__item"> <a href="../%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/Office/OnlyOffice.html" class="md-nav__link"> <span class="md-ellipsis"> OnlyOffice </span> </a> </li> <li class="md-nav__item"> <a href="../%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/Office/Poi-tl.html" class="md-nav__link"> <span class="md-ellipsis"> Poi-tl </span> </a> </li> <li class="md-nav__item"> <a href="../%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/Office/Spire.OfficeForJava.html" class="md-nav__link"> <span class="md-ellipsis"> Spire.OfficeForJava </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="../%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/PDF/ApachePDFBox.html" class="md-nav__link"> <span class="md-ellipsis"> ApachePDFBox </span> </a> </li> <li class="md-nav__item"> <a href="../%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/XML/XMLParse.html" class="md-nav__link"> <span class="md-ellipsis"> XMLParse </span> </a> </li> <li class="md-nav__item"> <a href="../%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/ZIP/Zip4j.html" class="md-nav__link"> <span class="md-ellipsis"> Zip4j </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="../%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/XXL-JOB.html" class="md-nav__link"> <span class="md-ellipsis"> XXL-JOB </span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_14" checked> <div class="md-nav__link md-nav__container"> <a href="Docker.html" class="md-nav__link md-nav__link--active"> <span class="md-ellipsis"> 🧑‍🔧 运维 </span> </a> <label class="md-nav__link md-nav__link--active" for="__nav_14" id="__nav_14_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_14_label" aria-expanded="true"> <label class="md-nav__title" for="__nav_14"> <span class="md-nav__icon md-icon"></span> 🧑‍🔧 运维 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="Linux.html" class="md-nav__link"> <span class="md-ellipsis"> Linux </span> </a> </li> <li class="md-nav__item"> <a href="NSSM.html" class="md-nav__link"> <span class="md-ellipsis"> NSSM </span> </a> </li> <li class="md-nav__item"> <a href="Nginx.html" class="md-nav__link"> <span class="md-ellipsis"> Nginx </span> </a> </li> <li class="md-nav__item"> <a href="Tomcat.html" class="md-nav__link"> <span class="md-ellipsis"> Tomcat </span> </a> </li> <li class="md-nav__item"> <a href="TongWeb.html" class="md-nav__link"> <span class="md-ellipsis"> TongWeb </span> </a> </li> <li class="md-nav__item"> <a href="WSL.html" class="md-nav__link"> <span class="md-ellipsis"> WSL </span> </a> </li> <li class="md-nav__item"> <a href="WebLogic.html" class="md-nav__link"> <span class="md-ellipsis"> WebLogic </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_15"> <div class="md-nav__link md-nav__container"> <a href="../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git.html" class="md-nav__link "> <span class="md-ellipsis"> 🛠️ 开发工具 </span> </a> <label class="md-nav__link " for="__nav_15" id="__nav_15_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_15_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_15"> <span class="md-nav__icon md-icon"></span> 🛠️ 开发工具 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven.html" class="md-nav__link"> <span class="md-ellipsis"> Maven </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Node.js.html" class="md-nav__link"> <span class="md-ellipsis"> Node.js </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Swagger.html" class="md-nav__link"> <span class="md-ellipsis"> Swagger </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_16"> <div class="md-nav__link md-nav__container"> <a href="../%E5%85%B6%E4%BB%96/Settings.html" class="md-nav__link "> <span class="md-ellipsis"> 👻 其他 </span> </a> <label class="md-nav__link " for="__nav_16" id="__nav_16_label" tabindex="0"> <span class="md-nav__icon md-icon"></span> </label> </div> <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_16_label" aria-expanded="false"> <label class="md-nav__title" for="__nav_16"> <span class="md-nav__icon md-icon"></span> 👻 其他 </label> <ul class="md-nav__list" data-md-scrollfix> <li class="md-nav__item"> <a href="../%E5%85%B6%E4%BB%96/Solutions.html" class="md-nav__link"> <span class="md-ellipsis"> Solutions </span> </a> </li> <li class="md-nav__item"> <a href="../%E5%85%B6%E4%BB%96/Weasel.html" class="md-nav__link"> <span class="md-ellipsis"> Weasel </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc"> <div class="md-sidebar__scrollwrap"> <div class="md-sidebar__inner"> <nav class="md-nav md-nav--secondary" aria-label="目录"> <label class="md-nav__title" for="__toc"> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix> <li class="md-nav__item"> <a href="#1简介" class="md-nav__link"> <span class="md-ellipsis"> 1、简介 </span> </a> <nav class="md-nav" aria-label="1、简介"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#11概述" class="md-nav__link"> <span class="md-ellipsis"> 1.1、概述 </span> </a> <nav class="md-nav" aria-label="1.1、概述"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#111什么是-docker" class="md-nav__link"> <span class="md-ellipsis"> 1.1.1、什么是 Docker </span> </a> </li> <li class="md-nav__item"> <a href="#112为什么要用-docker" class="md-nav__link"> <span class="md-ellipsis"> 1.1.2、为什么要用 Docker </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#12基本概念" class="md-nav__link"> <span class="md-ellipsis"> 1.2、基本概念 </span> </a> <nav class="md-nav" aria-label="1.2、基本概念"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#121镜像" class="md-nav__link"> <span class="md-ellipsis"> 1.2.1、镜像 </span> </a> </li> <li class="md-nav__item"> <a href="#122容器" class="md-nav__link"> <span class="md-ellipsis"> 1.2.2、容器 </span> </a> </li> <li class="md-nav__item"> <a href="#123仓库" class="md-nav__link"> <span class="md-ellipsis"> 1.2.3、仓库 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#13安装-docker" class="md-nav__link"> <span class="md-ellipsis"> 1.3、安装 Docker </span> </a> <nav class="md-nav" aria-label="1.3、安装 Docker"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#131windows" class="md-nav__link"> <span class="md-ellipsis"> 1.3.1、Windows </span> </a> </li> <li class="md-nav__item"> <a href="#132麒麟" class="md-nav__link"> <span class="md-ellipsis"> 1.3.2、麒麟 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#14镜像加速器" class="md-nav__link"> <span class="md-ellipsis"> 1.4、镜像加速器 </span> </a> <nav class="md-nav" aria-label="1.4、镜像加速器"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#141windows" class="md-nav__link"> <span class="md-ellipsis"> 1.4.1、Windows </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#2使用镜像" class="md-nav__link"> <span class="md-ellipsis"> 2、使用镜像 </span> </a> <nav class="md-nav" aria-label="2、使用镜像"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#21获取镜像" class="md-nav__link"> <span class="md-ellipsis"> 2.1、获取镜像 </span> </a> </li> <li class="md-nav__item"> <a href="#22列出镜像" class="md-nav__link"> <span class="md-ellipsis"> 2.2、列出镜像 </span> </a> <nav class="md-nav" aria-label="2.2、列出镜像"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#221中间层镜像" class="md-nav__link"> <span class="md-ellipsis"> 2.2.1、中间层镜像 </span> </a> </li> <li class="md-nav__item"> <a href="#222列出部分镜像" class="md-nav__link"> <span class="md-ellipsis"> 2.2.2、列出部分镜像 </span> </a> </li> <li class="md-nav__item"> <a href="#233以特定格式显示" class="md-nav__link"> <span class="md-ellipsis"> 2.3.3、以特定格式显示 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#23删除本地镜像" class="md-nav__link"> <span class="md-ellipsis"> 2.3、删除本地镜像 </span> </a> </li> <li class="md-nav__item"> <a href="#24保存和加载镜像" class="md-nav__link"> <span class="md-ellipsis"> 2.4、保存和加载镜像 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#3操作容器" class="md-nav__link"> <span class="md-ellipsis"> 3、操作容器 </span> </a> <nav class="md-nav" aria-label="3、操作容器"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#31启动容器" class="md-nav__link"> <span class="md-ellipsis"> 3.1、启动容器 </span> </a> <nav class="md-nav" aria-label="3.1、启动容器"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#311新建并启动容器" class="md-nav__link"> <span class="md-ellipsis"> 3.1.1、新建并启动容器 </span> </a> </li> <li class="md-nav__item"> <a href="#312启动已终止容器" class="md-nav__link"> <span class="md-ellipsis"> 3.1.2、启动已终止容器 </span> </a> </li> <li class="md-nav__item"> <a href="#313守护态启动容器" class="md-nav__link"> <span class="md-ellipsis"> 3.1.3、守护态启动容器 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#32终止容器" class="md-nav__link"> <span class="md-ellipsis"> 3.2、终止容器 </span> </a> </li> <li class="md-nav__item"> <a href="#33进入容器" class="md-nav__link"> <span class="md-ellipsis"> 3.3、进入容器 </span> </a> </li> <li class="md-nav__item"> <a href="#34导出和导入" class="md-nav__link"> <span class="md-ellipsis"> 3.4、导出和导入 </span> </a> </li> <li class="md-nav__item"> <a href="#35删除容器" class="md-nav__link"> <span class="md-ellipsis"> 3.5、删除容器 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#4访问仓库" class="md-nav__link"> <span class="md-ellipsis"> 4、访问仓库 </span> </a> <nav class="md-nav" aria-label="4、访问仓库"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#41docker-hub" class="md-nav__link"> <span class="md-ellipsis"> 4.1、Docker Hub </span> </a> </li> <li class="md-nav__item"> <a href="#42私有仓库" class="md-nav__link"> <span class="md-ellipsis"> 4.2、私有仓库 </span> </a> <nav class="md-nav" aria-label="4.2、私有仓库"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#421安装-docker-registry" class="md-nav__link"> <span class="md-ellipsis"> 4.2.1、安装 docker-registry </span> </a> </li> <li class="md-nav__item"> <a href="#422使用私有仓库" class="md-nav__link"> <span class="md-ellipsis"> 4.2.2、使用私有仓库 </span> </a> </li> <li class="md-nav__item"> <a href="#423配置非-https-地址" class="md-nav__link"> <span class="md-ellipsis"> 4.2.3、配置非 https 地址 </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#5数据管理" class="md-nav__link"> <span class="md-ellipsis"> 5、数据管理 </span> </a> <nav class="md-nav" aria-label="5、数据管理"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#51数据卷" class="md-nav__link"> <span class="md-ellipsis"> 5.1、数据卷 </span> </a> <nav class="md-nav" aria-label="5.1、数据卷"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#511创建数据卷" class="md-nav__link"> <span class="md-ellipsis"> 5.1.1、创建数据卷 </span> </a> </li> <li class="md-nav__item"> <a href="#512使用数据卷启动容器" class="md-nav__link"> <span class="md-ellipsis"> 5.1.2、使用数据卷启动容器 </span> </a> </li> <li class="md-nav__item"> <a href="#513删除数据卷" class="md-nav__link"> <span class="md-ellipsis"> 5.1.3、删除数据卷 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#52绑定挂载" class="md-nav__link"> <span class="md-ellipsis"> 5.2、绑定挂载 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#6使用网络" class="md-nav__link"> <span class="md-ellipsis"> 6、使用网络 </span> </a> <nav class="md-nav" aria-label="6、使用网络"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#61外部访问容器" class="md-nav__link"> <span class="md-ellipsis"> 6.1、外部访问容器 </span> </a> <nav class="md-nav" aria-label="6.1、外部访问容器"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#611查看映射端口配置" class="md-nav__link"> <span class="md-ellipsis"> 6.1.1、查看映射端口配置 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#62容器互联" class="md-nav__link"> <span class="md-ellipsis"> 6.2、容器互联 </span> </a> <nav class="md-nav" aria-label="6.2、容器互联"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#621新建网络" class="md-nav__link"> <span class="md-ellipsis"> 6.2.1、新建网络 </span> </a> </li> <li class="md-nav__item"> <a href="#622连接容器" class="md-nav__link"> <span class="md-ellipsis"> 6.2.2、连接容器 </span> </a> </li> <li class="md-nav__item"> <a href="#623测试互联" class="md-nav__link"> <span class="md-ellipsis"> 6.2.3、测试互联 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#63配置-dns" class="md-nav__link"> <span class="md-ellipsis"> 6.3、配置 DNS </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#7构建镜像" class="md-nav__link"> <span class="md-ellipsis"> 7、构建镜像 </span> </a> <nav class="md-nav" aria-label="7、构建镜像"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#71dockerfile-定制镜像" class="md-nav__link"> <span class="md-ellipsis"> 7.1、Dockerfile 定制镜像 </span> </a> <nav class="md-nav" aria-label="7.1、Dockerfile 定制镜像"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#711from" class="md-nav__link"> <span class="md-ellipsis"> 7.1.1、FROM </span> </a> </li> <li class="md-nav__item"> <a href="#712run" class="md-nav__link"> <span class="md-ellipsis"> 7.1.2、RUN </span> </a> </li> <li class="md-nav__item"> <a href="#713构建镜像" class="md-nav__link"> <span class="md-ellipsis"> 7.1.3、构建镜像 </span> </a> </li> <li class="md-nav__item"> <a href="#714镜像构建上下文" class="md-nav__link"> <span class="md-ellipsis"> 7.1.4、镜像构建上下文 </span> </a> </li> <li class="md-nav__item"> <a href="#715build-的其它用法" class="md-nav__link"> <span class="md-ellipsis"> 7.1.5、build 的其它用法 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#72dockerfile-指令详解" class="md-nav__link"> <span class="md-ellipsis"> 7.2、Dockerfile 指令详解 </span> </a> <nav class="md-nav" aria-label="7.2、Dockerfile 指令详解"> <ul class="md-nav__list"> <li class="md-nav__item"> <a href="#721copy" class="md-nav__link"> <span class="md-ellipsis"> 7.2.1、COPY </span> </a> </li> <li class="md-nav__item"> <a href="#722add" class="md-nav__link"> <span class="md-ellipsis"> 7.2.2、ADD </span> </a> </li> <li class="md-nav__item"> <a href="#723cmd" class="md-nav__link"> <span class="md-ellipsis"> 7.2.3、CMD </span> </a> </li> <li class="md-nav__item"> <a href="#724entrypoint" class="md-nav__link"> <span class="md-ellipsis"> 7.2.4、ENTRYPOINT </span> </a> </li> <li class="md-nav__item"> <a href="#725env" class="md-nav__link"> <span class="md-ellipsis"> 7.2.5、ENV </span> </a> </li> <li class="md-nav__item"> <a href="#726arg" class="md-nav__link"> <span class="md-ellipsis"> 7.2.6、ARG </span> </a> </li> <li class="md-nav__item"> <a href="#727volume" class="md-nav__link"> <span class="md-ellipsis"> 7.2.7、VOLUME </span> </a> </li> <li class="md-nav__item"> <a href="#728expose" class="md-nav__link"> <span class="md-ellipsis"> 7.2.8、EXPOSE </span> </a> </li> <li class="md-nav__item"> <a href="#729workdir" class="md-nav__link"> <span class="md-ellipsis"> 7.2.9、WORKDIR </span> </a> </li> <li class="md-nav__item"> <a href="#7210user" class="md-nav__link"> <span class="md-ellipsis"> 7.2.10、USER </span> </a> </li> <li class="md-nav__item"> <a href="#7211healthcheck" class="md-nav__link"> <span class="md-ellipsis"> 7.2.11、HEALTHCHECK </span> </a> </li> <li class="md-nav__item"> <a href="#7212onbuild" class="md-nav__link"> <span class="md-ellipsis"> 7.2.12、ONBUILD </span> </a> </li> <li class="md-nav__item"> <a href="#7213label" class="md-nav__link"> <span class="md-ellipsis"> 7.2.13、LABEL </span> </a> </li> <li class="md-nav__item"> <a href="#7214shell" class="md-nav__link"> <span class="md-ellipsis"> 7.2.14、SHELL </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item"> <a href="#73docker-buildx" class="md-nav__link"> <span class="md-ellipsis"> 7.3、Docker Buildx </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-content" data-md-component="content"> <article class="md-content__inner md-typeset"> <h1 id="docker">Docker<a class="headerlink" href="#docker" title="锚点链接">¶</a></h1> <h2 id="1简介">1、简介<a class="headerlink" href="#1简介" title="锚点链接">¶</a></h2> <h3 id="11概述">1.1、概述<a class="headerlink" href="#11概述" title="锚点链接">¶</a></h3> <h4 id="111什么是-docker">1.1.1、什么是 Docker<a class="headerlink" href="#111什么是-docker" title="锚点链接">¶</a></h4> <p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。</p> <p>Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</p> <p>Docker 使用 Google 公司推出的 Go 语言进行开发实现，基于 Linux 内核的 cgroup、namespace 以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 版本开始，则进一步演进为使用 runc 和 containerd。</p> <p><a class="glightbox" data-type="image" data-width="100%" data-height="auto" href="!assets/Docker/QQ_1726405952388.png" data-desc-position="bottom"><img src="!assets/Docker/QQ_1726405952388.png" alt="QQ_1726405952388" style="zoom:33%;"></a></p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>runc 是一个 Linux 命令行工具，用于根据 OCI 容器运行时规范 创建和运行容器。</p> <p>containerd 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</p> </div> <p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p> <p>Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p> <h4 id="112为什么要用-docker">1.1.2、为什么要用 Docker<a class="headerlink" href="#112为什么要用-docker" title="锚点链接">¶</a></h4> <p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p> <p><strong>更高效的利用系统资源</strong></p> <p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p> <p><strong>更快速的启动时间</strong></p> <p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p> <p><strong>一致的运行环境</strong></p> <p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现「这段代码在我机器上没问题啊」这类问题。</p> <p><strong>持续交付和部署</strong></p> <p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p> <p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合持续集成（Continuous Integration）系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署（Continuous Delivery/Deployment）系统进行自动部署。</p> <p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p> <p><strong>更轻松的迁移</strong></p> <p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p> <p><strong>更轻松的维护和扩展</strong></p> <p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p> <p><strong>对比传统虚拟机总结</strong></p> <table> <thead> <tr> <th style="text-align: left;">特性</th> <th style="text-align: left;">容器</th> <th style="text-align: left;">虚拟机</th> </tr> </thead> <tbody> <tr> <td style="text-align: left;">启动</td> <td style="text-align: left;">秒级</td> <td style="text-align: left;">分钟级</td> </tr> <tr> <td style="text-align: left;">硬盘使用</td> <td style="text-align: left;">一般为 MB</td> <td style="text-align: left;">一般为 GB</td> </tr> <tr> <td style="text-align: left;">性能</td> <td style="text-align: left;">接近原生</td> <td style="text-align: left;">弱于</td> </tr> <tr> <td style="text-align: left;">系统支持量</td> <td style="text-align: left;">单机支持上千个容器</td> <td style="text-align: left;">一般几十个</td> </tr> </tbody> </table> <h3 id="12基本概念">1.2、基本概念<a class="headerlink" href="#12基本概念" title="锚点链接">¶</a></h3> <p>Docker 包括三个基本概念：</p> <ul> <li>镜像（Image）</li> <li>容器（Container）</li> <li>仓库（Repository）</li> </ul> <p>理解了这三个概念，就理解了 Docker 的整个生命周期。</p> <h4 id="121镜像">1.2.1、镜像<a class="headerlink" href="#121镜像" title="锚点链接">¶</a></h4> <p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。</p> <p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p> <p><strong>分层存储</strong></p> <p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p> <p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p> <p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p> <h4 id="122容器">1.2.2、容器<a class="headerlink" href="#122容器" title="锚点链接">¶</a></h4> <p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p> <p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p> <p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为了容器运行时读写而准备的存储层为容器存储层。</p> <p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p> <p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p> <p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p> <h4 id="123仓库">1.2.3、仓库<a class="headerlink" href="#123仓库" title="锚点链接">¶</a></h4> <p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p> <p>一个 Docker Registry 中可以包含多个仓库（Repository），每个仓库可以包含多个标签（Tag），每个标签对应一个镜像。</p> <p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p> <p>以 Ubuntu 镜像为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如：16.04、18.04。我们可以通过 <code>ubuntu:16.04</code> 或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 <code>ubuntu:latest</code>。</p> <p>仓库名经常以两段式路径形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p> <p><strong>Docker Registry 公开服务</strong></p> <p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p> <p>最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 Red Hat 的 Quay.io、Google 的 Google Container Registry（Kubernetes 的镜像使用的就是这个服务）、代码托管平台 GitHub 推出的 ghcr.io。</p> <p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有阿里云加速器、DaoCloud 加速器等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。</p> <p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库等。</p> <p><strong>私有 Docker Registry</strong></p> <p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p> <p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 Docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p> <p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如 Harbor 和 Sonatype Nexus。</p> <h3 id="13安装-docker">1.3、安装 Docker<a class="headerlink" href="#13安装-docker" title="锚点链接">¶</a></h3> <p>Docker 分为 stable、test 和 nightly 三个更新频道。</p> <p>官方网站上有各种环境下的境下的<a href="https://docs.docker.com/get-docker/">安装指南</a>，这里主要介绍 Docker 在 Windows上的安装。</p> <h4 id="131windows">1.3.1、Windows<a class="headerlink" href="#131windows" title="锚点链接">¶</a></h4> <p><strong>系统要求</strong></p> <p><a href="https://docs.docker.com/docker-for-windows/install/">Docker Desktop for Windows</a> 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V（若版本为 v1903 及以上则无需开启 Hyper-V），或者 64 位版本的 Windows 10 Home v1903 及以上版本。</p> <p><strong>安装</strong></p> <ul> <li> <p>手动下载安装：</p> <p>点击<a href="https://desktop.docker.com/win/main/amd64/Docker Desktop Installer.exe">链接</a>下载 Docker Desktop for Windows，下载好之后双击 <code>Docker Desktop Installer.exe</code> 开始安装。</p> </li> <li> <p>使用 <code>winget</code> 安装：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a>winget<span class="w"> </span>install<span class="w"> </span>Docker.DockerDesktop
</span></code></pre></div> </li> </ul> <p><strong>在 WSL2 运行 Docker</strong></p> <p>若你的 Windows 版本为 Windows 10 专业版或家庭版 v1903 及以上版本可以使用 WSL2 运行 Docker，具体请查看 <a href="https://docs.docker.com/docker-for-windows/wsl/">Docker Desktop WSL 2 backend</a>。</p> <p><strong>运行</strong></p> <p>在 Windows 搜索栏输入 Docker，点击 Docker Desktop 开始运行。</p> <p>Docker 启动之后会在 Windows 任务栏出现鲸鱼图标：</p> <p><a class="glightbox" data-type="image" data-width="100%" data-height="auto" href="!assets/Docker/QQ_1726423569359.png" data-desc-position="bottom"><img src="!assets/Docker/QQ_1726423569359.png" alt="QQ_1726423569359" style="zoom: 25%;"></a></p> <p>等待片刻，当鲸鱼图标静止时，说明 Docker 启动成功，之后你可以打开 PowerShell 使用 Docker。</p> <p><strong>开放远程 API 访问</strong></p> <p>打开设置，勾选以下选项即可通过 2375 端口访问：</p> <p><a class="glightbox" data-type="image" data-width="100%" data-height="auto" href="!assets/Docker/image-20251209140546243.png" data-desc-position="bottom"><img src="!assets/Docker/image-20251209140546243.png" alt="image-20251209140546243" style="zoom: 50%;"></a></p> <p>访问 http://localhost:2375/version 测试：</p> <p><a class="glightbox" data-type="image" data-width="100%" data-height="auto" href="!assets/Docker/image-20251209140828779.png" data-desc-position="bottom"><img src="!assets/Docker/image-20251209140828779.png" alt="image-20251209140828779" style="zoom:50%;"></a></p> <div class="admonition warning"> <p class="admonition-title">Caution</p> <p>此方法开启没有安全访问，仅限内网或者本地学习使用，最好配置一层 Nginx 反向代理或者开启 HTTPS 访问。</p> <p>附上 Nginx 反向代理配置：</p> <div class="language-nginx highlight"><span class="filename">Nginx Configuration File</span><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="k">location</span><span class="w"> </span><span class="s">/docker/</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a><span class="w">       </span><span class="kn">proxy_pass</span><span class="w"> </span><span class="s">http://localhost:2375/</span><span class="p">;</span><span class="w"> </span>
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a><span class="w">       </span><span class="kn">client_max_body_size</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a><span class="w">       </span><span class="kn">proxy_connect_timeout</span><span class="w"> </span><span class="mi">3600</span><span class="p">;</span>
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a><span class="w">       </span><span class="kn">proxy_send_timeout</span><span class="w"> </span><span class="mi">3600</span><span class="p">;</span>
</span><span id="__span-1-6"><a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a><span class="w">       </span><span class="kn">proxy_read_timeout</span><span class="w"> </span><span class="mi">3600</span><span class="p">;</span>
</span><span id="__span-1-7"><a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a><span class="w">       </span><span class="kn">send_timeout</span><span class="w"> </span><span class="mi">3600</span><span class="p">;</span>
</span><span id="__span-1-8"><a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a><span class="w">       </span><span class="kn">proxy_set_header</span><span class="w"> </span><span class="s">Host</span><span class="w"> </span><span class="nv">$host</span><span class="p">;</span>
</span><span id="__span-1-9"><a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a><span class="w">       </span><span class="kn">proxy_set_header</span><span class="w"> </span><span class="s">X-Real-IP</span><span class="w"> </span><span class="nv">$remote_addr</span><span class="p">;</span>
</span><span id="__span-1-10"><a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a><span class="w">       </span><span class="kn">proxy_http_version</span><span class="w"> </span><span class="mi">1</span><span class="s">.1</span><span class="p">;</span>
</span><span id="__span-1-11"><a id="__codelineno-1-11" name="__codelineno-1-11" href="#__codelineno-1-11"></a><span class="w">       </span><span class="kn">proxy_set_header</span><span class="w"> </span><span class="s">Upgrade</span><span class="w"> </span><span class="nv">$http_upgrade</span><span class="p">;</span>
</span><span id="__span-1-12"><a id="__codelineno-1-12" name="__codelineno-1-12" href="#__codelineno-1-12"></a><span class="w">       </span><span class="kn">proxy_set_header</span><span class="w"> </span><span class="s">Connection</span><span class="w"> </span><span class="s">upgrade</span><span class="p">;</span>
</span><span id="__span-1-13"><a id="__codelineno-1-13" name="__codelineno-1-13" href="#__codelineno-1-13"></a><span class="p">}</span>
</span></code></pre></div> </div> <h4 id="132麒麟">1.3.2、麒麟<a class="headerlink" href="#132麒麟" title="锚点链接">¶</a></h4> <p>麒麟-Kylin 作为中国国产操作系统，基于 Linux 开发的商业操作系统。针对中国国企央企开发的系统，麒麟、统信大体都会接触过。既然是基于 Linux 开发的，软件按照就可以先尝试 Linux 对应架构的版本，如果运行有问题，再在对应的操作系统上进行编译操作。</p> <p>通过 <code>arch</code> 命令可以查看当前系统架构，一般会输出 <code>x86_64</code>、<code>armel</code> 、<code>aarch64</code> 等，在选择对应软件版本时也要选择对应的架构。</p> <ol> <li> <p>在 <a href="https://download.docker.com/linux/static/stable/">Docker 下载地址</a> 选择对应的架构，然后下载对应的版本即可；如果服务器可以联网，也可以直接复制命令下载：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>wget<span class="w"> </span>https://download.docker.com/linux/static/stable/x86_64/docker-20.10.19.tgz
</span></code></pre></div> </li> <li> <p>将安装包上传到服务器之后，执行命令完成解压：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>tar<span class="w"> </span>-xzf<span class="w"> </span>docker-20.10.19.tgz
</span></code></pre></div> <p>移动解压后的全部内容到 <code>/usr/bin</code> 下：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a>mv<span class="w"> </span>docker/*<span class="w"> </span>/usr/bin/
</span></code></pre></div> </li> <li> <p>编辑 <code>docker.service</code> 文件：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>vi<span class="w"> </span>/usr/lib/systemd/system/docker.service
</span></code></pre></div> <p>复制如下内容：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span class="o">[</span>Unit<span class="o">]</span>
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a><span class="nv">Description</span><span class="o">=</span>Docker<span class="w"> </span>Application<span class="w"> </span>Container<span class="w"> </span>Engine
</span><span id="__span-6-3"><a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a><span class="nv">Documentation</span><span class="o">=</span>https://docs.docker.com
</span><span id="__span-6-4"><a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a><span class="nv">After</span><span class="o">=</span>network-online.target<span class="w"> </span>firewalld.service
</span><span id="__span-6-5"><a id="__codelineno-6-5" name="__codelineno-6-5" href="#__codelineno-6-5"></a><span class="nv">Wants</span><span class="o">=</span>network-online.target
</span><span id="__span-6-6"><a id="__codelineno-6-6" name="__codelineno-6-6" href="#__codelineno-6-6"></a>
</span><span id="__span-6-7"><a id="__codelineno-6-7" name="__codelineno-6-7" href="#__codelineno-6-7"></a><span class="o">[</span>Service<span class="o">]</span>
</span><span id="__span-6-8"><a id="__codelineno-6-8" name="__codelineno-6-8" href="#__codelineno-6-8"></a><span class="nv">Type</span><span class="o">=</span>notify
</span><span id="__span-6-9"><a id="__codelineno-6-9" name="__codelineno-6-9" href="#__codelineno-6-9"></a><span class="nv">ExecStart</span><span class="o">=</span>/usr/bin/dockerd
</span><span id="__span-6-10"><a id="__codelineno-6-10" name="__codelineno-6-10" href="#__codelineno-6-10"></a><span class="nv">ExecReload</span><span class="o">=</span>/bin/kill<span class="w"> </span>-s<span class="w"> </span>HUP<span class="w"> </span><span class="nv">$MAINPID</span>
</span><span id="__span-6-11"><a id="__codelineno-6-11" name="__codelineno-6-11" href="#__codelineno-6-11"></a><span class="nv">LimitNOFILE</span><span class="o">=</span>infinity
</span><span id="__span-6-12"><a id="__codelineno-6-12" name="__codelineno-6-12" href="#__codelineno-6-12"></a><span class="nv">LimitNPROC</span><span class="o">=</span>infinity
</span><span id="__span-6-13"><a id="__codelineno-6-13" name="__codelineno-6-13" href="#__codelineno-6-13"></a><span class="nv">TimeoutStartSec</span><span class="o">=</span><span class="m">0</span>
</span><span id="__span-6-14"><a id="__codelineno-6-14" name="__codelineno-6-14" href="#__codelineno-6-14"></a><span class="nv">Delegate</span><span class="o">=</span>yes
</span><span id="__span-6-15"><a id="__codelineno-6-15" name="__codelineno-6-15" href="#__codelineno-6-15"></a><span class="nv">KillMode</span><span class="o">=</span>process
</span><span id="__span-6-16"><a id="__codelineno-6-16" name="__codelineno-6-16" href="#__codelineno-6-16"></a><span class="nv">Restart</span><span class="o">=</span>on-failure
</span><span id="__span-6-17"><a id="__codelineno-6-17" name="__codelineno-6-17" href="#__codelineno-6-17"></a><span class="nv">StartLimitBurst</span><span class="o">=</span><span class="m">3</span>
</span><span id="__span-6-18"><a id="__codelineno-6-18" name="__codelineno-6-18" href="#__codelineno-6-18"></a><span class="nv">StartLimitInterval</span><span class="o">=</span>60s
</span><span id="__span-6-19"><a id="__codelineno-6-19" name="__codelineno-6-19" href="#__codelineno-6-19"></a>
</span><span id="__span-6-20"><a id="__codelineno-6-20" name="__codelineno-6-20" href="#__codelineno-6-20"></a><span class="o">[</span>Install<span class="o">]</span>
</span><span id="__span-6-21"><a id="__codelineno-6-21" name="__codelineno-6-21" href="#__codelineno-6-21"></a><span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</span></code></pre></div> </li> <li> <p>添加 docker.service 文件的权限：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a>chmod<span class="w"> </span>+x<span class="w"> </span>/usr/lib/systemd/system/docker.service
</span></code></pre></div> <p>通知 systemd 守护进程重新读取配置文件：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-8-1"><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a>systemctl<span class="w"> </span>daemon-reload
</span></code></pre></div> </li> <li> <p>启动 Docker，设置开机启动：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-9-1"><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a>systemctl<span class="w"> </span>start<span class="w"> </span>docker
</span><span id="__span-9-2"><a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a>systemctl<span class="w"> </span><span class="nb">enable</span><span class="w"> </span>docker
</span></code></pre></div> </li> <li> <p>验证 Docker 安装是否成功：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-10-1"><a id="__codelineno-10-1" name="__codelineno-10-1" href="#__codelineno-10-1"></a>docker<span class="w"> </span>-v
</span></code></pre></div> <p>输出对应版本，即是成功！</p> </li> </ol> <h3 id="14镜像加速器">1.4、镜像加速器<a class="headerlink" href="#14镜像加速器" title="锚点链接">¶</a></h3> <p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如：</p> <ul> <li>阿里云加速器：点击管理控制台 =&gt; 登录账号 =&gt; 左侧镜像工具 =&gt; 镜像加速器 =&gt; 复制加速器地址。</li> <li>网易云加速器：https://hub-mirror.c.163.com。</li> <li>百度云加速器：https://mirror.baidubce.com。</li> </ul> <p>由于镜像服务可能出现宕机，建议同时配置多个镜像。各个镜像站测试结果请到 <a href="https://github.com/docker-practice/docker-registry-cn-mirror-test/actions">docker-practice/docker-registry-cn-mirror-test</a> 查看。</p> <p><strong>检查加速器是否生效</strong></p> <p>执行 <code>docker system info</code> 命令（常用别名为 <code>docker info</code>），如果从结果中看到了如下内容，说明配置成功：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-11-1"><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a>Registry Mirrors:
</span><span id="__span-11-2"><a id="__codelineno-11-2" name="__codelineno-11-2" href="#__codelineno-11-2"></a> https://hub-mirror.c.163.com/
</span></code></pre></div> <p><strong>不再提供服务的镜像</strong></p> <p>某些镜像不再提供服务，添加无用的镜像加速器，会拖慢镜像拉取速度，你可以从镜像配置列表中删除它们。</p> <p>建议 watch <a href="https://github.com/docker-practice/docker-registry-cn-mirror-test">镜像测试</a>这个 GitHub 仓库，这里会更新各个镜像地址的状态。</p> <h4 id="141windows">1.4.1、Windows<a class="headerlink" href="#141windows" title="锚点链接">¶</a></h4> <p>对于使用 Windows 的用户，在 Docker Desktop 中打开配置窗口后在左侧导航菜单选择 Docker Engine，编辑右侧的 json 文件，之后点击 Apply &amp; Restart 保存后 Docker 就会重启并应用配置的镜像地址了。</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-12-1"><a id="__codelineno-12-1" name="__codelineno-12-1" href="#__codelineno-12-1"></a>{
</span><span id="__span-12-2"><a id="__codelineno-12-2" name="__codelineno-12-2" href="#__codelineno-12-2"></a>  "registry-mirrors": [
</span><span id="__span-12-3"><a id="__codelineno-12-3" name="__codelineno-12-3" href="#__codelineno-12-3"></a>    "https://hub-mirror.c.163.com",
</span><span id="__span-12-4"><a id="__codelineno-12-4" name="__codelineno-12-4" href="#__codelineno-12-4"></a>    "https://mirror.baidubce.com"
</span><span id="__span-12-5"><a id="__codelineno-12-5" name="__codelineno-12-5" href="#__codelineno-12-5"></a>  ]
</span><span id="__span-12-6"><a id="__codelineno-12-6" name="__codelineno-12-6" href="#__codelineno-12-6"></a>}
</span></code></pre></div> <h2 id="2使用镜像">2、使用镜像<a class="headerlink" href="#2使用镜像" title="锚点链接">¶</a></h2> <p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p> <p>Docker 管理镜像的主要命令为 <code>docker image</code>，其下包含以下子命令：</p> <table> <thead> <tr> <th style="text-align: left;">命令</th> <th style="text-align: left;">描述</th> </tr> </thead> <tbody> <tr> <td style="text-align: left;"><code>docker image history</code></td> <td style="text-align: left;">显示镜像的历史记录。</td> </tr> <tr> <td style="text-align: left;"><code>docker image import</code></td> <td style="text-align: left;">从 tarball 导入内容以创建文件系统镜像。</td> </tr> <tr> <td style="text-align: left;"><code>docker image inspect</code></td> <td style="text-align: left;">显示一个或多个镜像的详细信息。</td> </tr> <tr> <td style="text-align: left;"><code>docker image load</code></td> <td style="text-align: left;">从 tar 存档或 STDIN 加载镜像。</td> </tr> <tr> <td style="text-align: left;"><code>docker image prune</code></td> <td style="text-align: left;">移除未使用的镜像。</td> </tr> <tr> <td style="text-align: left;"><code>docker image rm</code></td> <td style="text-align: left;">移除一个或多个镜像。</td> </tr> <tr> <td style="text-align: left;"><code>docker image save</code></td> <td style="text-align: left;">将一个或多个镜像保存到 tar 存档（默认情况下流式传输到 STDOUT）。</td> </tr> <tr> <td style="text-align: left;"><code>docker image tag</code></td> <td style="text-align: left;">创建一个指向 SOURCE_IMAGE 的 TARGET_IMAGE 标签。</td> </tr> <tr> <td style="text-align: left;"><code>docker image ls</code></td> <td style="text-align: left;">列出镜像。</td> </tr> <tr> <td style="text-align: left;"><code>docker image pull</code></td> <td style="text-align: left;">从 Registry 下载镜像。</td> </tr> <tr> <td style="text-align: left;"><code>docker image push</code></td> <td style="text-align: left;">将镜像上传到 Registry。</td> </tr> </tbody> </table> <h3 id="21获取镜像">2.1、获取镜像<a class="headerlink" href="#21获取镜像" title="锚点链接">¶</a></h3> <p><a href="https://hub.docker.com/search?q=&amp;type=image">Docker Hub</a> 上有大量的高质量的镜像可以用，从 Docker 镜像仓库获取镜像的命令是 <code>docker image pull</code>（常用别名为 <code>docker pull</code>）。其命令格式为：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-13-1"><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a>docker<span class="w"> </span>pull<span class="w"> </span><span class="o">[</span>选项<span class="o">]</span><span class="w"> </span><span class="o">[</span>Docker<span class="w"> </span>Registry<span class="w"> </span>地址<span class="o">[</span>:端口号<span class="o">]</span>/<span class="o">]</span>仓库名<span class="o">[</span>:标签<span class="o">]</span>
</span></code></pre></div> <p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里说一下镜像名称的格式：</p> <ul> <li><em>Docker Registry 地址</em>：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub（docker.io）。</li> <li><em>仓库名</em>：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</li> </ul> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-14-1"><a id="__codelineno-14-1" name="__codelineno-14-1" href="#__codelineno-14-1"></a>$ docker pull ubuntu:18.04
</span><span id="__span-14-2"><a id="__codelineno-14-2" name="__codelineno-14-2" href="#__codelineno-14-2"></a>18.04: Pulling from library/ubuntu
</span><span id="__span-14-3"><a id="__codelineno-14-3" name="__codelineno-14-3" href="#__codelineno-14-3"></a>92dc2a97ff99: Pull complete
</span><span id="__span-14-4"><a id="__codelineno-14-4" name="__codelineno-14-4" href="#__codelineno-14-4"></a>be13a9d27eb8: Pull complete
</span><span id="__span-14-5"><a id="__codelineno-14-5" name="__codelineno-14-5" href="#__codelineno-14-5"></a>c8299583700a: Pull complete
</span><span id="__span-14-6"><a id="__codelineno-14-6" name="__codelineno-14-6" href="#__codelineno-14-6"></a>Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26
</span><span id="__span-14-7"><a id="__codelineno-14-7" name="__codelineno-14-7" href="#__codelineno-14-7"></a>Status: Downloaded newer image for ubuntu:18.04
</span><span id="__span-14-8"><a id="__codelineno-14-8" name="__codelineno-14-8" href="#__codelineno-14-8"></a>docker.io/library/ubuntu:18.04
</span></code></pre></div> <p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub（docker.io）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 18.04 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p> <p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。</p> <p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 sha256 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p> <h3 id="22列出镜像">2.2、列出镜像<a class="headerlink" href="#22列出镜像" title="锚点链接">¶</a></h3> <p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令（常用别名为 <code>docker images</code>）：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-15-1"><a id="__codelineno-15-1" name="__codelineno-15-1" href="#__codelineno-15-1"></a>$ docker images
</span><span id="__span-15-2"><a id="__codelineno-15-2" name="__codelineno-15-2" href="#__codelineno-15-2"></a>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
</span><span id="__span-15-3"><a id="__codelineno-15-3" name="__codelineno-15-3" href="#__codelineno-15-3"></a>redis                latest              5f515359c7f8        5 days ago          183 MB
</span><span id="__span-15-4"><a id="__codelineno-15-4" name="__codelineno-15-4" href="#__codelineno-15-4"></a>nginx                latest              05a60462f8ba        5 days ago          181 MB
</span><span id="__span-15-5"><a id="__codelineno-15-5" name="__codelineno-15-5" href="#__codelineno-15-5"></a>mongo                3.2                 fe9198c04d62        5 days ago          342 MB
</span><span id="__span-15-6"><a id="__codelineno-15-6" name="__codelineno-15-6" href="#__codelineno-15-6"></a>&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB
</span><span id="__span-15-7"><a id="__codelineno-15-7" name="__codelineno-15-7" href="#__codelineno-15-7"></a>ubuntu               18.04               329ed837d508        3 days ago          63.3MB
</span><span id="__span-15-8"><a id="__codelineno-15-8" name="__codelineno-15-8" href="#__codelineno-15-8"></a>ubuntu               bionic              329ed837d508        3 days ago          63.3MB
</span></code></pre></div> <p>列表包含了 仓库名、标签、镜像 ID、创建时间以及所占用的空间。</p> <p>镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。因此，在上面的例子中，可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p> <p><strong>镜像体积</strong></p> <p>如果仔细观察会注意到这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如 <code>ubuntu:18.04</code> 镜像大小在这里是 63.3 MB，但是在 <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/bionic/images/sha256-32776cc92b5810ce72e77aca1d949de1f348e1d281d3f00ebcc22a3adcdc9f42?context=explore">Docker Hub</a> 显示的却是 25.47 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker images</code> 显示的是镜像下载到本地后展开的大小，准确说是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候更关心的是本地磁盘空间占用的大小。</p> <p>另外一个需要注意的问题是 <code>docker images</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p> <p>你可以通过 <code>docker system df</code> 命令来便捷的查看镜像、容器、数据卷所占用的空间：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-16-1"><a id="__codelineno-16-1" name="__codelineno-16-1" href="#__codelineno-16-1"></a>$ docker system df
</span><span id="__span-16-2"><a id="__codelineno-16-2" name="__codelineno-16-2" href="#__codelineno-16-2"></a>
</span><span id="__span-16-3"><a id="__codelineno-16-3" name="__codelineno-16-3" href="#__codelineno-16-3"></a>TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
</span><span id="__span-16-4"><a id="__codelineno-16-4" name="__codelineno-16-4" href="#__codelineno-16-4"></a>Images              24                  0                   1.992GB             1.992GB (100%)
</span><span id="__span-16-5"><a id="__codelineno-16-5" name="__codelineno-16-5" href="#__codelineno-16-5"></a>Containers          1                   0                   62.82MB             62.82MB (100%)
</span><span id="__span-16-6"><a id="__codelineno-16-6" name="__codelineno-16-6" href="#__codelineno-16-6"></a>Local Volumes       9                   0                   652.2MB             652.2MB (100%)
</span><span id="__span-16-7"><a id="__codelineno-16-7" name="__codelineno-16-7" href="#__codelineno-16-7"></a>Build Cache                                                 0B                  0B
</span></code></pre></div> <p><strong>虚悬镜像</strong></p> <p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-17-1"><a id="__codelineno-17-1" name="__codelineno-17-1" href="#__codelineno-17-1"></a>&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB
</span></code></pre></div> <p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为虚悬镜像（dangling image），可以用 <code>docker images -f dangling=true</code> 命令专门显示这类镜像：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-18-1"><a id="__codelineno-18-1" name="__codelineno-18-1" href="#__codelineno-18-1"></a>$ docker images -f dangling=true
</span><span id="__span-18-2"><a id="__codelineno-18-2" name="__codelineno-18-2" href="#__codelineno-18-2"></a>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span><span id="__span-18-3"><a id="__codelineno-18-3" name="__codelineno-18-3" href="#__codelineno-18-3"></a>&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB
</span></code></pre></div> <p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用 <code>docker image prune</code> 命令删除。</p> <h4 id="221中间层镜像">2.2.1、中间层镜像<a class="headerlink" href="#221中间层镜像" title="锚点链接">¶</a></h4> <p>为了加速镜像构建、重复利用资源，Docker 会利用中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker images</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-19-1"><a id="__codelineno-19-1" name="__codelineno-19-1" href="#__codelineno-19-1"></a>docker<span class="w"> </span>images<span class="w"> </span>-a
</span></code></pre></div> <p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p> <h4 id="222列出部分镜像">2.2.2、列出部分镜像<a class="headerlink" href="#222列出部分镜像" title="锚点链接">¶</a></h4> <p>不加任何参数的情况下，<code>docker images</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker images</code> 有好几个参数可以帮助做到这个事情。</p> <p>根据仓库名列出镜像：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-20-1"><a id="__codelineno-20-1" name="__codelineno-20-1" href="#__codelineno-20-1"></a>$ docker images ubuntu
</span><span id="__span-20-2"><a id="__codelineno-20-2" name="__codelineno-20-2" href="#__codelineno-20-2"></a>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span><span id="__span-20-3"><a id="__codelineno-20-3" name="__codelineno-20-3" href="#__codelineno-20-3"></a>ubuntu              18.04               329ed837d508        3 days ago          63.3MB
</span><span id="__span-20-4"><a id="__codelineno-20-4" name="__codelineno-20-4" href="#__codelineno-20-4"></a>ubuntu              bionic              329ed837d508        3 days ago          63.3MB
</span></code></pre></div> <p>列出特定的某个镜像，也就是说指定仓库名和标签：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-21-1"><a id="__codelineno-21-1" name="__codelineno-21-1" href="#__codelineno-21-1"></a>$ docker images ubuntu:18.04
</span><span id="__span-21-2"><a id="__codelineno-21-2" name="__codelineno-21-2" href="#__codelineno-21-2"></a>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span><span id="__span-21-3"><a id="__codelineno-21-3" name="__codelineno-21-3" href="#__codelineno-21-3"></a>ubuntu              18.04               329ed837d508        3 days ago          63.3MB
</span></code></pre></div> <p>除此以外，<code>docker images</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>，比如我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-22-1"><a id="__codelineno-22-1" name="__codelineno-22-1" href="#__codelineno-22-1"></a>$ docker images -f since=mongo:3.2
</span><span id="__span-22-2"><a id="__codelineno-22-2" name="__codelineno-22-2" href="#__codelineno-22-2"></a>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span><span id="__span-22-3"><a id="__codelineno-22-3" name="__codelineno-22-3" href="#__codelineno-22-3"></a>redis               latest              5f515359c7f8        5 days ago          183 MB
</span><span id="__span-22-4"><a id="__codelineno-22-4" name="__codelineno-22-4" href="#__codelineno-22-4"></a>nginx               latest              05a60462f8ba        5 days ago          181 MB
</span></code></pre></div> <p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p> <p>此外，如果镜像构建时定义了 <code>LABEL</code> 还可以通过 <code>LABEL</code> 来过滤：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-23-1"><a id="__codelineno-23-1" name="__codelineno-23-1" href="#__codelineno-23-1"></a>docker<span class="w"> </span>images<span class="w"> </span>-f<span class="w"> </span><span class="nv">label</span><span class="o">=</span>com.example.version<span class="o">=</span><span class="m">0</span>.1
</span></code></pre></div> <h4 id="233以特定格式显示">2.3.3、以特定格式显示<a class="headerlink" href="#233以特定格式显示" title="锚点链接">¶</a></h4> <p>默认情况下 <code>docker images</code> 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker images</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker rmi</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数（quiet：只显示镜像 ID，不显示其他信息）：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-24-1"><a id="__codelineno-24-1" name="__codelineno-24-1" href="#__codelineno-24-1"></a>$ docker images -q
</span><span id="__span-24-2"><a id="__codelineno-24-2" name="__codelineno-24-2" href="#__codelineno-24-2"></a>5f515359c7f8
</span><span id="__span-24-3"><a id="__codelineno-24-3" name="__codelineno-24-3" href="#__codelineno-24-3"></a>05a60462f8ba
</span><span id="__span-24-4"><a id="__codelineno-24-4" name="__codelineno-24-4" href="#__codelineno-24-4"></a>fe9198c04d62
</span><span id="__span-24-5"><a id="__codelineno-24-5" name="__codelineno-24-5" href="#__codelineno-24-5"></a>00285df0df87
</span><span id="__span-24-6"><a id="__codelineno-24-6" name="__codelineno-24-6" href="#__codelineno-24-6"></a>329ed837d508
</span><span id="__span-24-7"><a id="__codelineno-24-7" name="__codelineno-24-7" href="#__codelineno-24-7"></a>329ed837d508
</span></code></pre></div> <p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p> <p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 <code>docker images --format</code> 命令和 <a href="https://gohugo.io/templates/introduction/">Go 的模板语法</a>：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-25-1"><a id="__codelineno-25-1" name="__codelineno-25-1" href="#__codelineno-25-1"></a>docker<span class="w"> </span>images<span class="w"> </span>--format<span class="w"> </span><span class="s2">"{{.&lt;字段名称&gt;}}"</span>
</span></code></pre></div> <p>其中，字段名称是 Docker 镜像的属性字段，支持的字段包括：</p> <ul> <li><code>Repository</code>：镜像仓库名称</li> <li><code>Tag</code>：镜像标签。</li> <li><code>ID</code>：镜像 ID。</li> <li><code>CreatedSince</code>：镜像创建时间（相对时间）。</li> <li><code>Size</code>：镜像大小。</li> <li><code>Digest</code>：镜像摘要（仅适用于某些镜像）。</li> </ul> <p>比如，下面的命令会直接列出镜像结果，并且只包含镜像 ID 和仓库名：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-26-1"><a id="__codelineno-26-1" name="__codelineno-26-1" href="#__codelineno-26-1"></a>$ docker images --format "{{.ID}}: {{.Repository}}"
</span><span id="__span-26-2"><a id="__codelineno-26-2" name="__codelineno-26-2" href="#__codelineno-26-2"></a>5f515359c7f8: redis
</span><span id="__span-26-3"><a id="__codelineno-26-3" name="__codelineno-26-3" href="#__codelineno-26-3"></a>05a60462f8ba: nginx
</span><span id="__span-26-4"><a id="__codelineno-26-4" name="__codelineno-26-4" href="#__codelineno-26-4"></a>fe9198c04d62: mongo
</span><span id="__span-26-5"><a id="__codelineno-26-5" name="__codelineno-26-5" href="#__codelineno-26-5"></a>00285df0df87: &lt;none&gt;
</span><span id="__span-26-6"><a id="__codelineno-26-6" name="__codelineno-26-6" href="#__codelineno-26-6"></a>329ed837d508: ubuntu
</span><span id="__span-26-7"><a id="__codelineno-26-7" name="__codelineno-26-7" href="#__codelineno-26-7"></a>329ed837d508: ubuntu
</span></code></pre></div> <p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-27-1"><a id="__codelineno-27-1" name="__codelineno-27-1" href="#__codelineno-27-1"></a>$ docker images --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}"
</span><span id="__span-27-2"><a id="__codelineno-27-2" name="__codelineno-27-2" href="#__codelineno-27-2"></a>IMAGE ID            REPOSITORY          TAG
</span><span id="__span-27-3"><a id="__codelineno-27-3" name="__codelineno-27-3" href="#__codelineno-27-3"></a>5f515359c7f8        redis               latest
</span><span id="__span-27-4"><a id="__codelineno-27-4" name="__codelineno-27-4" href="#__codelineno-27-4"></a>05a60462f8ba        nginx               latest
</span><span id="__span-27-5"><a id="__codelineno-27-5" name="__codelineno-27-5" href="#__codelineno-27-5"></a>fe9198c04d62        mongo               3.2
</span><span id="__span-27-6"><a id="__codelineno-27-6" name="__codelineno-27-6" href="#__codelineno-27-6"></a>00285df0df87        &lt;none&gt;              &lt;none&gt;
</span><span id="__span-27-7"><a id="__codelineno-27-7" name="__codelineno-27-7" href="#__codelineno-27-7"></a>329ed837d508        ubuntu              18.04
</span><span id="__span-27-8"><a id="__codelineno-27-8" name="__codelineno-27-8" href="#__codelineno-27-8"></a>329ed837d508        ubuntu              bionic
</span></code></pre></div> <h3 id="23删除本地镜像">2.3、删除本地镜像<a class="headerlink" href="#23删除本地镜像" title="锚点链接">¶</a></h3> <p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令（常用别名为 <code>docker rmi</code>），其格式为：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-28-1"><a id="__codelineno-28-1" name="__codelineno-28-1" href="#__codelineno-28-1"></a>docker<span class="w"> </span>rmi<span class="w"> </span><span class="o">[</span>选项<span class="o">]</span><span class="w"> </span>&lt;镜像1&gt;<span class="w"> </span><span class="o">[</span>&lt;镜像2&gt;<span class="w"> </span>...<span class="o">]</span>
</span></code></pre></div> <p><strong>用 ID、镜像名、摘要删除镜像</strong></p> <p>其中，<code>&lt;镜像&gt;</code> 可以是镜像短 ID、镜像长 ID、镜像名或者镜像摘要。</p> <p>比如我们有这么一些镜像：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-29-1"><a id="__codelineno-29-1" name="__codelineno-29-1" href="#__codelineno-29-1"></a>$ docker images
</span><span id="__span-29-2"><a id="__codelineno-29-2" name="__codelineno-29-2" href="#__codelineno-29-2"></a>REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
</span><span id="__span-29-3"><a id="__codelineno-29-3" name="__codelineno-29-3" href="#__codelineno-29-3"></a>centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB
</span><span id="__span-29-4"><a id="__codelineno-29-4" name="__codelineno-29-4" href="#__codelineno-29-4"></a>redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB
</span><span id="__span-29-5"><a id="__codelineno-29-5" name="__codelineno-29-5" href="#__codelineno-29-5"></a>docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB
</span><span id="__span-29-6"><a id="__codelineno-29-6" name="__codelineno-29-6" href="#__codelineno-29-6"></a>nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB
</span></code></pre></div> <p>我们可以用镜像的完整 ID（也称为长 ID），来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用短 ID 来删除镜像。<code>docker images</code> 默认列出的就已经是短 ID 了，一般取前 3 个字符以上，只要足够区分于别的镜像就可以了。</p> <p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-30-1"><a id="__codelineno-30-1" name="__codelineno-30-1" href="#__codelineno-30-1"></a>$ docker rmi 501
</span><span id="__span-30-2"><a id="__codelineno-30-2" name="__codelineno-30-2" href="#__codelineno-30-2"></a>Untagged: redis:alpine
</span><span id="__span-30-3"><a id="__codelineno-30-3" name="__codelineno-30-3" href="#__codelineno-30-3"></a>Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d
</span><span id="__span-30-4"><a id="__codelineno-30-4" name="__codelineno-30-4" href="#__codelineno-30-4"></a>Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7
</span><span id="__span-30-5"><a id="__codelineno-30-5" name="__codelineno-30-5" href="#__codelineno-30-5"></a>Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b
</span><span id="__span-30-6"><a id="__codelineno-30-6" name="__codelineno-30-6" href="#__codelineno-30-6"></a>Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23
</span><span id="__span-30-7"><a id="__codelineno-30-7" name="__codelineno-30-7" href="#__codelineno-30-7"></a>Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa
</span><span id="__span-30-8"><a id="__codelineno-30-8" name="__codelineno-30-8" href="#__codelineno-30-8"></a>Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3
</span><span id="__span-30-9"><a id="__codelineno-30-9" name="__codelineno-30-9" href="#__codelineno-30-9"></a>Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7
</span></code></pre></div> <p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-31-1"><a id="__codelineno-31-1" name="__codelineno-31-1" href="#__codelineno-31-1"></a>$ docker rmi centos
</span><span id="__span-31-2"><a id="__codelineno-31-2" name="__codelineno-31-2" href="#__codelineno-31-2"></a>Untagged: centos:latest
</span><span id="__span-31-3"><a id="__codelineno-31-3" name="__codelineno-31-3" href="#__codelineno-31-3"></a>Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c
</span><span id="__span-31-4"><a id="__codelineno-31-4" name="__codelineno-31-4" href="#__codelineno-31-4"></a>Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a
</span><span id="__span-31-5"><a id="__codelineno-31-5" name="__codelineno-31-5" href="#__codelineno-31-5"></a>Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38
</span></code></pre></div> <p>当然，更精确的是使用镜像摘要删除镜像：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-32-1"><a id="__codelineno-32-1" name="__codelineno-32-1" href="#__codelineno-32-1"></a>$ docker images --digests
</span><span id="__span-32-2"><a id="__codelineno-32-2" name="__codelineno-32-2" href="#__codelineno-32-2"></a>REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE
</span><span id="__span-32-3"><a id="__codelineno-32-3" name="__codelineno-32-3" href="#__codelineno-32-3"></a>node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB
</span><span id="__span-32-4"><a id="__codelineno-32-4" name="__codelineno-32-4" href="#__codelineno-32-4"></a>
</span><span id="__span-32-5"><a id="__codelineno-32-5" name="__codelineno-32-5" href="#__codelineno-32-5"></a>$ docker rmi node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
</span><span id="__span-32-6"><a id="__codelineno-32-6" name="__codelineno-32-6" href="#__codelineno-32-6"></a>Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228
</span></code></pre></div> <p><strong>Untagged 和 Deleted</strong></p> <p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p> <p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker rmi</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p> <p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p> <p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p> <p><strong>用 <code>docker images</code> 命令来配合</strong></p> <p>像其它可以承接多个实体的命令一样，可以使用 <code>docker images -q</code> 来配合使用 <code>docker rmi</code>，这样可以成批的删除希望删除的镜像。</p> <p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-33-1"><a id="__codelineno-33-1" name="__codelineno-33-1" href="#__codelineno-33-1"></a>docker<span class="w"> </span>rmi<span class="w"> </span><span class="k">$(</span>docker<span class="w"> </span>images<span class="w"> </span>-q<span class="w"> </span>redis<span class="k">)</span>
</span></code></pre></div> <p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-34-1"><a id="__codelineno-34-1" name="__codelineno-34-1" href="#__codelineno-34-1"></a>docker<span class="w"> </span>rmi<span class="w"> </span><span class="k">$(</span>docker<span class="w"> </span>images<span class="w"> </span>-q<span class="w"> </span>-f<span class="w"> </span><span class="nv">before</span><span class="o">=</span>mongo:3.2<span class="k">)</span>
</span></code></pre></div> <p>充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。</p> <h3 id="24保存和加载镜像">2.4、保存和加载镜像<a class="headerlink" href="#24保存和加载镜像" title="锚点链接">¶</a></h3> <h2 id="3操作容器">3、操作容器<a class="headerlink" href="#3操作容器" title="锚点链接">¶</a></h2> <p>容器是 Docker 又一核心概念。</p> <p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p> <p>Docker 管理容器的命令为 <code>docker container</code>，其下有以下子命令：</p> <table> <thead> <tr> <th style="text-align: left;">命令</th> <th style="text-align: left;">描述</th> </tr> </thead> <tbody> <tr> <td style="text-align: left;"><code>docker container attach</code></td> <td style="text-align: left;">将本地标准输入、输出和错误流附加到正在运行的容器。</td> </tr> <tr> <td style="text-align: left;"><code>docker container commit</code></td> <td style="text-align: left;">根据容器的更改创建新的镜像。</td> </tr> <tr> <td style="text-align: left;"><code>docker container cp</code></td> <td style="text-align: left;">复制容器和本地文件系统之间的文件/文件夹。</td> </tr> <tr> <td style="text-align: left;"><code>docker container create</code></td> <td style="text-align: left;">创建一个新的容器。</td> </tr> <tr> <td style="text-align: left;"><code>docker container diff</code></td> <td style="text-align: left;">检查容器文件系统上文件或目录的更改。</td> </tr> <tr> <td style="text-align: left;"><code>docker container export</code></td> <td style="text-align: left;">将容器的文件系统导出为 tar 存档。</td> </tr> <tr> <td style="text-align: left;"><code>docker container inspect</code></td> <td style="text-align: left;">显示一个或多个容器的详细信息。</td> </tr> <tr> <td style="text-align: left;"><code>docker container kill</code></td> <td style="text-align: left;">终止一个或多个正在运行的容器。</td> </tr> <tr> <td style="text-align: left;"><code>docker container logs</code></td> <td style="text-align: left;">获取容器的日志。</td> </tr> <tr> <td style="text-align: left;"><code>docker container pause</code></td> <td style="text-align: left;">暂停一个或多个容器中的所有进程。</td> </tr> <tr> <td style="text-align: left;"><code>docker container port</code></td> <td style="text-align: left;">列出容器的端口映射或特定映射。</td> </tr> <tr> <td style="text-align: left;"><code>docker container prune</code></td> <td style="text-align: left;">删除所有已停止的容器。</td> </tr> <tr> <td style="text-align: left;"><code>docker container rename</code></td> <td style="text-align: left;">重命名容器。</td> </tr> <tr> <td style="text-align: left;"><code>docker container restart</code></td> <td style="text-align: left;">重启一个或多个容器。</td> </tr> <tr> <td style="text-align: left;"><code>docker container rm</code></td> <td style="text-align: left;">删除一个或多个容器。</td> </tr> <tr> <td style="text-align: left;"><code>docker container start</code></td> <td style="text-align: left;">启动一个或多个已停止的容器。</td> </tr> <tr> <td style="text-align: left;"><code>docker container stats</code></td> <td style="text-align: left;">显示容器资源使用情况统计信息的实时流。</td> </tr> <tr> <td style="text-align: left;"><code>docker container stop</code></td> <td style="text-align: left;">停止一个或多个正在运行的容器。</td> </tr> <tr> <td style="text-align: left;"><code>docker container top</code></td> <td style="text-align: left;">显示容器的运行进程。</td> </tr> <tr> <td style="text-align: left;"><code>docker container unpause</code></td> <td style="text-align: left;">取消暂停一个或多个容器中的所有进程。</td> </tr> <tr> <td style="text-align: left;"><code>docker container update</code></td> <td style="text-align: left;">更新一个或多个容器的配置。</td> </tr> <tr> <td style="text-align: left;"><code>docker container wait</code></td> <td style="text-align: left;">阻塞直到一个或多个容器停止，然后打印它们的退出代码。</td> </tr> <tr> <td style="text-align: left;"><code>docker container exec</code></td> <td style="text-align: left;">在正在运行的容器中执行命令。</td> </tr> <tr> <td style="text-align: left;"><code>docker container ls</code></td> <td style="text-align: left;">列出容器。</td> </tr> <tr> <td style="text-align: left;"><code>docker container run</code></td> <td style="text-align: left;">根据镜像创建并运行新容器。</td> </tr> </tbody> </table> <h3 id="31启动容器">3.1、启动容器<a class="headerlink" href="#31启动容器" title="锚点链接">¶</a></h3> <p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p> <p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p> <h4 id="311新建并启动容器">3.1.1、新建并启动容器<a class="headerlink" href="#311新建并启动容器" title="锚点链接">¶</a></h4> <p>所需要的命令主要为 <code>docker container run</code>（常用别名为 <code>docker run</code>）。</p> <p>例如，下面的命令输出一个 “Hello World”，之后终止容器：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-35-1"><a id="__codelineno-35-1" name="__codelineno-35-1" href="#__codelineno-35-1"></a>$ docker run ubuntu:18.04 /bin/echo 'Hello world'
</span><span id="__span-35-2"><a id="__codelineno-35-2" name="__codelineno-35-2" href="#__codelineno-35-2"></a>Hello world
</span></code></pre></div> <p>这跟在本地直接执行 <code>/bin/echo 'hello world'</code> 几乎感觉不出任何区别。</p> <p>下面的命令则启动一个 bash 终端，允许用户进行交互：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-36-1"><a id="__codelineno-36-1" name="__codelineno-36-1" href="#__codelineno-36-1"></a>$ docker run -t -i ubuntu:18.04 /bin/bash
</span><span id="__span-36-2"><a id="__codelineno-36-2" name="__codelineno-36-2" href="#__codelineno-36-2"></a>root@af8bae53bdd3:/#
</span></code></pre></div> <p>其中，<code>-t</code> 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p> <p>在交互模式下，用户可以通过所创建的终端来输入命令，例如：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-37-1"><a id="__codelineno-37-1" name="__codelineno-37-1" href="#__codelineno-37-1"></a>root@af8bae53bdd3:/# pwd
</span><span id="__span-37-2"><a id="__codelineno-37-2" name="__codelineno-37-2" href="#__codelineno-37-2"></a>/
</span><span id="__span-37-3"><a id="__codelineno-37-3" name="__codelineno-37-3" href="#__codelineno-37-3"></a>root@af8bae53bdd3:/# ls
</span><span id="__span-37-4"><a id="__codelineno-37-4" name="__codelineno-37-4" href="#__codelineno-37-4"></a>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
</span></code></pre></div> <p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p> <ul> <li>检查本地是否存在指定的镜像，不存在就从 registry 下载。</li> <li>利用镜像创建并启动一个容器。</li> <li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层。</li> <li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。</li> <li>从地址池配置一个 ip 地址给容器。</li> <li>执行用户指定的应用程序。</li> <li>执行完毕后容器被终止。</li> </ul> <h4 id="312启动已终止容器">3.1.2、启动已终止容器<a class="headerlink" href="#312启动已终止容器" title="锚点链接">¶</a></h4> <p>可以利用 <code>docker container start</code> 命令（常用别名为 <code>docker start</code>），直接将一个已经终止（<code>exited</code>）的容器启动运行。</p> <p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-38-1"><a id="__codelineno-38-1" name="__codelineno-38-1" href="#__codelineno-38-1"></a>root@ba267838cc1b:/# ps
</span><span id="__span-38-2"><a id="__codelineno-38-2" name="__codelineno-38-2" href="#__codelineno-38-2"></a>  PID TTY          TIME CMD
</span><span id="__span-38-3"><a id="__codelineno-38-3" name="__codelineno-38-3" href="#__codelineno-38-3"></a>    1 ?        00:00:00 bash
</span><span id="__span-38-4"><a id="__codelineno-38-4" name="__codelineno-38-4" href="#__codelineno-38-4"></a>   11 ?        00:00:00 ps
</span></code></pre></div> <p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p> <h4 id="313守护态启动容器">3.1.3、守护态启动容器<a class="headerlink" href="#313守护态启动容器" title="锚点链接">¶</a></h4> <p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p> <p>如果不使用 <code>-d</code> 参数运行容器：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-39-1"><a id="__codelineno-39-1" name="__codelineno-39-1" href="#__codelineno-39-1"></a>$ docker run ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"
</span><span id="__span-39-2"><a id="__codelineno-39-2" name="__codelineno-39-2" href="#__codelineno-39-2"></a>hello world
</span><span id="__span-39-3"><a id="__codelineno-39-3" name="__codelineno-39-3" href="#__codelineno-39-3"></a>hello world
</span><span id="__span-39-4"><a id="__codelineno-39-4" name="__codelineno-39-4" href="#__codelineno-39-4"></a>hello world
</span><span id="__span-39-5"><a id="__codelineno-39-5" name="__codelineno-39-5" href="#__codelineno-39-5"></a>hello world
</span></code></pre></div> <p>容器会把输出的结果（STDOUT）打印到宿主机上面。</p> <p>如果使用了 <code>-d</code> 参数运行容器：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-40-1"><a id="__codelineno-40-1" name="__codelineno-40-1" href="#__codelineno-40-1"></a>$ docker run -d ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"
</span><span id="__span-40-2"><a id="__codelineno-40-2" name="__codelineno-40-2" href="#__codelineno-40-2"></a>77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
</span></code></pre></div> <p>启动后会返回一个唯一的 ID，此时容器会在后台运行并不会把输出的结果（STDOUT）打印到宿主机上面。</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p> </div> <p>可以通过 <code>docker container ls</code> 命令（常用别名为 <code>docker ps</code>）来查看容器信息：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-41-1"><a id="__codelineno-41-1" name="__codelineno-41-1" href="#__codelineno-41-1"></a>$ docker ps
</span><span id="__span-41-2"><a id="__codelineno-41-2" name="__codelineno-41-2" href="#__codelineno-41-2"></a>CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES
</span><span id="__span-41-3"><a id="__codelineno-41-3" name="__codelineno-41-3" href="#__codelineno-41-3"></a>77b2dc01fe0f  ubuntu:18.04  /bin/sh -c 'while tr  2 minutes ago  Up 1 minute        agitated_wright
</span></code></pre></div> <p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令（常用别名为 <code>docker logs</code>）：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-42-1"><a id="__codelineno-42-1" name="__codelineno-42-1" href="#__codelineno-42-1"></a>$ docker logs [container ID or NAMES]
</span><span id="__span-42-2"><a id="__codelineno-42-2" name="__codelineno-42-2" href="#__codelineno-42-2"></a>hello world
</span><span id="__span-42-3"><a id="__codelineno-42-3" name="__codelineno-42-3" href="#__codelineno-42-3"></a>hello world
</span><span id="__span-42-4"><a id="__codelineno-42-4" name="__codelineno-42-4" href="#__codelineno-42-4"></a>hello world
</span><span id="__span-42-5"><a id="__codelineno-42-5" name="__codelineno-42-5" href="#__codelineno-42-5"></a>. . .
</span></code></pre></div> <h3 id="32终止容器">3.2、终止容器<a class="headerlink" href="#32终止容器" title="锚点链接">¶</a></h3> <p>可以使用 <code>docker container stop</code> 命令（常用别名为 <code>docker stop</code>）来终止一个运行中的容器。</p> <p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p> <p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p> <p>终止状态的容器可以用 <code>docker ps -a</code> 命令看到。例如：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-43-1"><a id="__codelineno-43-1" name="__codelineno-43-1" href="#__codelineno-43-1"></a>$ docker ps -a
</span><span id="__span-43-2"><a id="__codelineno-43-2" name="__codelineno-43-2" href="#__codelineno-43-2"></a>CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES
</span><span id="__span-43-3"><a id="__codelineno-43-3" name="__codelineno-43-3" href="#__codelineno-43-3"></a>ba267838cc1b        ubuntu:18.04             "/bin/bash"            30 minutes ago      Exited (0) About a minute ago                       trusting_newton
</span></code></pre></div> <p>处于终止状态的容器，可以通过 <code>docker start</code> 命令来重新启动。</p> <p>此外，<code>docker container restart</code> 命令（常用别名为 <code>docker restart</code>）会将一个运行态的容器终止，然后再重新启动它。</p> <h3 id="33进入容器">3.3、进入容器<a class="headerlink" href="#33进入容器" title="锚点链接">¶</a></h3> <p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p> <p>某些时候需要进入容器进行操作，可以使用 <code>docker container attach</code> 命令（常用别名为 <code>docker attach</code>）或 <code>docker container exec</code> 命令（常用别名为 <code>docker exec</code>），推荐使用 <code>docker exec</code> 命令。</p> <p><strong><code>docker attach</code> 命令</strong></p> <p>下面示例如何使用 <code>docker attach</code> 命令：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-44-1"><a id="__codelineno-44-1" name="__codelineno-44-1" href="#__codelineno-44-1"></a>$ docker run -itd ubuntu
</span><span id="__span-44-2"><a id="__codelineno-44-2" name="__codelineno-44-2" href="#__codelineno-44-2"></a>243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550
</span><span id="__span-44-3"><a id="__codelineno-44-3" name="__codelineno-44-3" href="#__codelineno-44-3"></a>
</span><span id="__span-44-4"><a id="__codelineno-44-4" name="__codelineno-44-4" href="#__codelineno-44-4"></a>$ docker ps
</span><span id="__span-44-5"><a id="__codelineno-44-5" name="__codelineno-44-5" href="#__codelineno-44-5"></a>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</span><span id="__span-44-6"><a id="__codelineno-44-6" name="__codelineno-44-6" href="#__codelineno-44-6"></a>243c32535da7        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia
</span><span id="__span-44-7"><a id="__codelineno-44-7" name="__codelineno-44-7" href="#__codelineno-44-7"></a>
</span><span id="__span-44-8"><a id="__codelineno-44-8" name="__codelineno-44-8" href="#__codelineno-44-8"></a>$ docker attach 243c
</span><span id="__span-44-9"><a id="__codelineno-44-9" name="__codelineno-44-9" href="#__codelineno-44-9"></a>root@243c32535da7:/#
</span></code></pre></div> <div class="admonition tip"> <p class="admonition-title">Important</p> <p>如果从这个 STDOUT 中 <code>exit</code>，会导致容器的停止。</p> </div> <p><strong><code>docker exec</code> 命令</strong></p> <p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code>、<code>-t</code> 参数。</p> <p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p> <p>当 <code>-i</code>、<code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-45-1"><a id="__codelineno-45-1" name="__codelineno-45-1" href="#__codelineno-45-1"></a>$ docker run -itd ubuntu
</span><span id="__span-45-2"><a id="__codelineno-45-2" name="__codelineno-45-2" href="#__codelineno-45-2"></a>69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6
</span><span id="__span-45-3"><a id="__codelineno-45-3" name="__codelineno-45-3" href="#__codelineno-45-3"></a>
</span><span id="__span-45-4"><a id="__codelineno-45-4" name="__codelineno-45-4" href="#__codelineno-45-4"></a>$ docker ps
</span><span id="__span-45-5"><a id="__codelineno-45-5" name="__codelineno-45-5" href="#__codelineno-45-5"></a>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</span><span id="__span-45-6"><a id="__codelineno-45-6" name="__codelineno-45-6" href="#__codelineno-45-6"></a>69d137adef7a        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           zealous_swirles
</span><span id="__span-45-7"><a id="__codelineno-45-7" name="__codelineno-45-7" href="#__codelineno-45-7"></a>
</span><span id="__span-45-8"><a id="__codelineno-45-8" name="__codelineno-45-8" href="#__codelineno-45-8"></a>$ docker exec -i 69d1 bash
</span><span id="__span-45-9"><a id="__codelineno-45-9" name="__codelineno-45-9" href="#__codelineno-45-9"></a>ls
</span><span id="__span-45-10"><a id="__codelineno-45-10" name="__codelineno-45-10" href="#__codelineno-45-10"></a>bin
</span><span id="__span-45-11"><a id="__codelineno-45-11" name="__codelineno-45-11" href="#__codelineno-45-11"></a>boot
</span><span id="__span-45-12"><a id="__codelineno-45-12" name="__codelineno-45-12" href="#__codelineno-45-12"></a>dev
</span><span id="__span-45-13"><a id="__codelineno-45-13" name="__codelineno-45-13" href="#__codelineno-45-13"></a>...
</span><span id="__span-45-14"><a id="__codelineno-45-14" name="__codelineno-45-14" href="#__codelineno-45-14"></a>
</span><span id="__span-45-15"><a id="__codelineno-45-15" name="__codelineno-45-15" href="#__codelineno-45-15"></a>$ docker exec -it 69d1 bash
</span><span id="__span-45-16"><a id="__codelineno-45-16" name="__codelineno-45-16" href="#__codelineno-45-16"></a>root@69d137adef7a:/#
</span></code></pre></div> <div class="admonition tip"> <p class="admonition-title">Important</p> <p>如果从这个 STDOUT 中 <code>exit</code>，不会导致容器的停止。这就是为什么推荐使用 <code>docker exec</code> 的原因。</p> </div> <h3 id="34导出和导入">3.4、导出和导入<a class="headerlink" href="#34导出和导入" title="锚点链接">¶</a></h3> <p><strong>导出容器</strong></p> <p>如果要导出本地某个容器，可以使用 <code>docker container export</code> 命令（常用别名为 <code>docker export</code>）：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-46-1"><a id="__codelineno-46-1" name="__codelineno-46-1" href="#__codelineno-46-1"></a>$ docker ps -a
</span><span id="__span-46-2"><a id="__codelineno-46-2" name="__codelineno-46-2" href="#__codelineno-46-2"></a>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
</span><span id="__span-46-3"><a id="__codelineno-46-3" name="__codelineno-46-3" href="#__codelineno-46-3"></a>7691a814370e        ubuntu:18.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test
</span><span id="__span-46-4"><a id="__codelineno-46-4" name="__codelineno-46-4" href="#__codelineno-46-4"></a>$ docker export 7691a814370e &gt; ubuntu.tar
</span></code></pre></div> <p>这样将导出容器快照到本地文件。</p> <p><strong>导入容器快照</strong></p> <p>可以使用 <code>docker image import</code> 命令（常用别名为 <code>docker import</code>）从容器快照文件中再导入为镜像，例如：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-47-1"><a id="__codelineno-47-1" name="__codelineno-47-1" href="#__codelineno-47-1"></a>$ cat ubuntu.tar | docker import - test/ubuntu:v1.0
</span><span id="__span-47-2"><a id="__codelineno-47-2" name="__codelineno-47-2" href="#__codelineno-47-2"></a>$ docker images
</span><span id="__span-47-3"><a id="__codelineno-47-3" name="__codelineno-47-3" href="#__codelineno-47-3"></a>REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
</span><span id="__span-47-4"><a id="__codelineno-47-4" name="__codelineno-47-4" href="#__codelineno-47-4"></a>test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB
</span></code></pre></div> <p>此外，也可以通过指定 URL 或者某个目录来导入，例如：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-48-1"><a id="__codelineno-48-1" name="__codelineno-48-1" href="#__codelineno-48-1"></a>docker<span class="w"> </span>import<span class="w"> </span>http://example.com/exampleimage.tgz<span class="w"> </span>example/imagerepo
</span></code></pre></div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>用户既可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库，也可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p> </div> <h3 id="35删除容器">3.5、删除容器<a class="headerlink" href="#35删除容器" title="锚点链接">¶</a></h3> <p><strong>删除容器</strong></p> <p>可以使用 <code>docker container rm</code> 命令（常用别名为 <code>docker rm</code>）来删除一个处于终止状态的容器。例如：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-49-1"><a id="__codelineno-49-1" name="__codelineno-49-1" href="#__codelineno-49-1"></a>$ docker rm trusting_newton
</span><span id="__span-49-2"><a id="__codelineno-49-2" name="__codelineno-49-2" href="#__codelineno-49-2"></a>trusting_newton
</span></code></pre></div> <p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p> <p><strong>清理所有处于终止状态的容器</strong></p> <p>用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 <code>docker container prune</code> 命令可以清理掉所有处于终止状态的容器。</p> <h2 id="4访问仓库">4、访问仓库<a class="headerlink" href="#4访问仓库" title="锚点链接">¶</a></h2> <p>仓库（Repository）是集中存放镜像的地方。</p> <p>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p> <p>大部分时候，并不需要严格区分这两者的概念。</p> <p>Docker 访问仓库涉及以下常用命令：</p> <table> <thead> <tr> <th style="text-align: left;">命令</th> <th style="text-align: left;">描述</th> </tr> </thead> <tbody> <tr> <td style="text-align: left;"><code>docker login</code></td> <td style="text-align: left;">验证注册表身份。</td> </tr> <tr> <td style="text-align: left;"><code>docker logout</code></td> <td style="text-align: left;">从注册表注销。如果未指定服务器，则默认服务器由守护进程定义。</td> </tr> <tr> <td style="text-align: left;"><code>docker search</code></td> <td style="text-align: left;">搜索 Docker Hub中 的镜像。</td> </tr> </tbody> </table> <h3 id="41docker-hub">4.1、Docker Hub<a class="headerlink" href="#41docker-hub" title="锚点链接">¶</a></h3> <p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p> <p><strong>注册</strong></p> <p>你可以在 https://hub.docker.com 免费注册一个 Docker 账号。</p> <p><strong>登录</strong></p> <p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p> <p>你可以通过 <code>docker logout</code> 退出登录。</p> <p><strong>拉取镜像</strong></p> <p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p> <p>例如以 centos 为关键词进行搜索：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-50-1"><a id="__codelineno-50-1" name="__codelineno-50-1" href="#__codelineno-50-1"></a>$ docker search centos
</span><span id="__span-50-2"><a id="__codelineno-50-2" name="__codelineno-50-2" href="#__codelineno-50-2"></a>NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
</span><span id="__span-50-3"><a id="__codelineno-50-3" name="__codelineno-50-3" href="#__codelineno-50-3"></a>centos                             The official build of CentOS.                   6449      [OK]
</span><span id="__span-50-4"><a id="__codelineno-50-4" name="__codelineno-50-4" href="#__codelineno-50-4"></a>ansible/centos7-ansible            Ansible on Centos7                              132                  [OK]
</span><span id="__span-50-5"><a id="__codelineno-50-5" name="__codelineno-50-5" href="#__codelineno-50-5"></a>consol/centos-xfce-vnc             Centos container with "headless" VNC session…   126                  [OK]
</span><span id="__span-50-6"><a id="__codelineno-50-6" name="__codelineno-50-6" href="#__codelineno-50-6"></a>jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   117                  [OK]
</span><span id="__span-50-7"><a id="__codelineno-50-7" name="__codelineno-50-7" href="#__codelineno-50-7"></a>centos/systemd                     systemd enabled base container.                 96                   [OK]
</span></code></pre></div> <p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（<code>OFFICIAL</code>）、是否自动构建 （<code>AUTOMATED</code>）。</p> <p>根据是否是官方提供，可将镜像分为两类。</p> <p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p> <p>还有一种类型，比如 <code>ansible/centos7-ansible</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 ansible 用户。</p> <p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p> <p>下载官方 <code>centos</code> 镜像到本地：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-51-1"><a id="__codelineno-51-1" name="__codelineno-51-1" href="#__codelineno-51-1"></a>$ docker pull centos
</span><span id="__span-51-2"><a id="__codelineno-51-2" name="__codelineno-51-2" href="#__codelineno-51-2"></a>Using default tag: latest
</span><span id="__span-51-3"><a id="__codelineno-51-3" name="__codelineno-51-3" href="#__codelineno-51-3"></a>latest: Pulling from library/centos
</span><span id="__span-51-4"><a id="__codelineno-51-4" name="__codelineno-51-4" href="#__codelineno-51-4"></a>7a0437f04f83: Pull complete
</span><span id="__span-51-5"><a id="__codelineno-51-5" name="__codelineno-51-5" href="#__codelineno-51-5"></a>Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1
</span><span id="__span-51-6"><a id="__codelineno-51-6" name="__codelineno-51-6" href="#__codelineno-51-6"></a>Status: Downloaded newer image for centos:latest
</span><span id="__span-51-7"><a id="__codelineno-51-7" name="__codelineno-51-7" href="#__codelineno-51-7"></a>docker.io/library/centos:latest
</span></code></pre></div> <p><strong>推送镜像</strong></p> <p>用户也可以在登录后通过 <code>docker image push</code> 命令（常用别名为 <code>docker push</code>）来将自己的镜像推送到 Docker Hub。</p> <p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-52-1"><a id="__codelineno-52-1" name="__codelineno-52-1" href="#__codelineno-52-1"></a>$ docker tag ubuntu:18.04 username/ubuntu:18.04
</span><span id="__span-52-2"><a id="__codelineno-52-2" name="__codelineno-52-2" href="#__codelineno-52-2"></a>
</span><span id="__span-52-3"><a id="__codelineno-52-3" name="__codelineno-52-3" href="#__codelineno-52-3"></a>$ docker images
</span><span id="__span-52-4"><a id="__codelineno-52-4" name="__codelineno-52-4" href="#__codelineno-52-4"></a>
</span><span id="__span-52-5"><a id="__codelineno-52-5" name="__codelineno-52-5" href="#__codelineno-52-5"></a>REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE
</span><span id="__span-52-6"><a id="__codelineno-52-6" name="__codelineno-52-6" href="#__codelineno-52-6"></a>ubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MB
</span><span id="__span-52-7"><a id="__codelineno-52-7" name="__codelineno-52-7" href="#__codelineno-52-7"></a>username/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB
</span><span id="__span-52-8"><a id="__codelineno-52-8" name="__codelineno-52-8" href="#__codelineno-52-8"></a>
</span><span id="__span-52-9"><a id="__codelineno-52-9" name="__codelineno-52-9" href="#__codelineno-52-9"></a>$ docker push username/ubuntu:18.04
</span><span id="__span-52-10"><a id="__codelineno-52-10" name="__codelineno-52-10" href="#__codelineno-52-10"></a>
</span><span id="__span-52-11"><a id="__codelineno-52-11" name="__codelineno-52-11" href="#__codelineno-52-11"></a>$ docker search username
</span><span id="__span-52-12"><a id="__codelineno-52-12" name="__codelineno-52-12" href="#__codelineno-52-12"></a>
</span><span id="__span-52-13"><a id="__codelineno-52-13" name="__codelineno-52-13" href="#__codelineno-52-13"></a>NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
</span><span id="__span-52-14"><a id="__codelineno-52-14" name="__codelineno-52-14" href="#__codelineno-52-14"></a>username/ubuntu
</span></code></pre></div> <h3 id="42私有仓库">4.2、私有仓库<a class="headerlink" href="#42私有仓库" title="锚点链接">¶</a></h3> <p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p> <p><a href="https://docs.docker.com/registry/"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 docker-registry v2.x 版本。</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Docker Registry 是容器镜像仓库的开源实现。它于 2019 年捐赠给云原生计算基金会 (CNCF)，并以 “Distribution” 的名义进行维护。它仍然是管理和分发容器镜像的基石。</p> <p><a href="https://github.com/distribution/distribution">CNCF Distribution CNCF 分发</a></p> </div> <h4 id="421安装-docker-registry">4.2.1、安装 docker-registry<a class="headerlink" href="#421安装-docker-registry" title="锚点链接">¶</a></h4> <p>你可以使用官方 <code>registry</code> 镜像来运行：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-53-1"><a id="__codelineno-53-1" name="__codelineno-53-1" href="#__codelineno-53-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>-p<span class="w"> </span><span class="m">5000</span>:5000<span class="w"> </span>--restart<span class="o">=</span>always<span class="w"> </span>--name<span class="w"> </span>registry<span class="w"> </span>registry
</span></code></pre></div> <p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-54-1"><a id="__codelineno-54-1" name="__codelineno-54-1" href="#__codelineno-54-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>-p<span class="w"> </span><span class="m">5000</span>:5000<span class="w"> </span>-v<span class="w"> </span>/opt/data/registry:/var/lib/registry<span class="w"> </span>registry
</span></code></pre></div> <h4 id="422使用私有仓库">4.2.2、使用私有仓库<a class="headerlink" href="#422使用私有仓库" title="锚点链接">¶</a></h4> <p>创建好私有仓库之后，就可以使用 <code>docker image tag</code> 命令（常用别名为 <code>docker tag</code>）来标记一个镜像，然后推送到仓库。<code>docker tag</code> 格式为：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-55-1"><a id="__codelineno-55-1" name="__codelineno-55-1" href="#__codelineno-55-1"></a>docker<span class="w"> </span>tag<span class="w"> </span>IMAGE<span class="o">[</span>:TAG<span class="o">]</span><span class="w"> </span><span class="o">[</span>REGISTRY_HOST<span class="o">[</span>:REGISTRY_PORT<span class="o">]</span>/<span class="o">]</span>REPOSITORY<span class="o">[</span>:TAG<span class="o">]</span>
</span></code></pre></div> <p><strong>示例</strong></p> <p>例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p> <ol> <li> <p>先在本机查看已有的镜像：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-56-1"><a id="__codelineno-56-1" name="__codelineno-56-1" href="#__codelineno-56-1"></a>$ docker images
</span><span id="__span-56-2"><a id="__codelineno-56-2" name="__codelineno-56-2" href="#__codelineno-56-2"></a>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
</span><span id="__span-56-3"><a id="__codelineno-56-3" name="__codelineno-56-3" href="#__codelineno-56-3"></a>ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB
</span></code></pre></div> </li> <li> <p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-57-1"><a id="__codelineno-57-1" name="__codelineno-57-1" href="#__codelineno-57-1"></a>$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest
</span><span id="__span-57-2"><a id="__codelineno-57-2" name="__codelineno-57-2" href="#__codelineno-57-2"></a>$ docker images
</span><span id="__span-57-3"><a id="__codelineno-57-3" name="__codelineno-57-3" href="#__codelineno-57-3"></a>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
</span><span id="__span-57-4"><a id="__codelineno-57-4" name="__codelineno-57-4" href="#__codelineno-57-4"></a>ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB
</span><span id="__span-57-5"><a id="__codelineno-57-5" name="__codelineno-57-5" href="#__codelineno-57-5"></a>127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB
</span></code></pre></div> </li> <li> <p>使用 <code>docker push</code> 上传标记的镜像：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-58-1"><a id="__codelineno-58-1" name="__codelineno-58-1" href="#__codelineno-58-1"></a>$ docker push 127.0.0.1:5000/ubuntu:latest
</span><span id="__span-58-2"><a id="__codelineno-58-2" name="__codelineno-58-2" href="#__codelineno-58-2"></a>The push refers to repository [127.0.0.1:5000/ubuntu]
</span><span id="__span-58-3"><a id="__codelineno-58-3" name="__codelineno-58-3" href="#__codelineno-58-3"></a>373a30c24545: Pushed
</span><span id="__span-58-4"><a id="__codelineno-58-4" name="__codelineno-58-4" href="#__codelineno-58-4"></a>a9148f5200b0: Pushed
</span><span id="__span-58-5"><a id="__codelineno-58-5" name="__codelineno-58-5" href="#__codelineno-58-5"></a>cdd3de0940ab: Pushed
</span><span id="__span-58-6"><a id="__codelineno-58-6" name="__codelineno-58-6" href="#__codelineno-58-6"></a>fc56279bbb33: Pushed
</span><span id="__span-58-7"><a id="__codelineno-58-7" name="__codelineno-58-7" href="#__codelineno-58-7"></a>b38367233d37: Pushed
</span><span id="__span-58-8"><a id="__codelineno-58-8" name="__codelineno-58-8" href="#__codelineno-58-8"></a>2aebd096e0e2: Pushed
</span><span id="__span-58-9"><a id="__codelineno-58-9" name="__codelineno-58-9" href="#__codelineno-58-9"></a>latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568
</span></code></pre></div> </li> <li> <p>用 <code>curl</code> 查看仓库中的镜像：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-59-1"><a id="__codelineno-59-1" name="__codelineno-59-1" href="#__codelineno-59-1"></a>$ curl 127.0.0.1:5000/v2/_catalog
</span><span id="__span-59-2"><a id="__codelineno-59-2" name="__codelineno-59-2" href="#__codelineno-59-2"></a>{"repositories":["ubuntu"]}
</span></code></pre></div> <p>这里可以看到 <code>{"repositories":["ubuntu"]}</code>，表明镜像已经被成功上传了。</p> </li> <li> <p>先删除已有镜像，再尝试从私有仓库中下载这个镜像：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-60-1"><a id="__codelineno-60-1" name="__codelineno-60-1" href="#__codelineno-60-1"></a>$ docker rmi 127.0.0.1:5000/ubuntu:latest
</span><span id="__span-60-2"><a id="__codelineno-60-2" name="__codelineno-60-2" href="#__codelineno-60-2"></a>
</span><span id="__span-60-3"><a id="__codelineno-60-3" name="__codelineno-60-3" href="#__codelineno-60-3"></a>$ docker pull 127.0.0.1:5000/ubuntu:latest
</span><span id="__span-60-4"><a id="__codelineno-60-4" name="__codelineno-60-4" href="#__codelineno-60-4"></a>Pulling repository 127.0.0.1:5000/ubuntu:latest
</span><span id="__span-60-5"><a id="__codelineno-60-5" name="__codelineno-60-5" href="#__codelineno-60-5"></a>ba5877dc9bec: Download complete
</span><span id="__span-60-6"><a id="__codelineno-60-6" name="__codelineno-60-6" href="#__codelineno-60-6"></a>511136ea3c5a: Download complete
</span><span id="__span-60-7"><a id="__codelineno-60-7" name="__codelineno-60-7" href="#__codelineno-60-7"></a>9bad880da3d2: Download complete
</span><span id="__span-60-8"><a id="__codelineno-60-8" name="__codelineno-60-8" href="#__codelineno-60-8"></a>25f11f5fb0cb: Download complete
</span><span id="__span-60-9"><a id="__codelineno-60-9" name="__codelineno-60-9" href="#__codelineno-60-9"></a>ebc34468f71d: Download complete
</span><span id="__span-60-10"><a id="__codelineno-60-10" name="__codelineno-60-10" href="#__codelineno-60-10"></a>2318d26665ef: Download complete
</span><span id="__span-60-11"><a id="__codelineno-60-11" name="__codelineno-60-11" href="#__codelineno-60-11"></a>
</span><span id="__span-60-12"><a id="__codelineno-60-12" name="__codelineno-60-12" href="#__codelineno-60-12"></a>$ docker images
</span><span id="__span-60-13"><a id="__codelineno-60-13" name="__codelineno-60-13" href="#__codelineno-60-13"></a>REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
</span><span id="__span-60-14"><a id="__codelineno-60-14" name="__codelineno-60-14" href="#__codelineno-60-14"></a>127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB
</span></code></pre></div> </li> </ol> <h4 id="423配置非-https-地址">4.2.3、配置非 https 地址<a class="headerlink" href="#423配置非-https-地址" title="锚点链接">¶</a></h4> <p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p> <p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制。</p> <p><strong>Ubuntu 16.04+、Debian 8+、centos 7</strong></p> <p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p> <div class="language-json highlight"><span class="filename">JSON</span><pre><span></span><code><span id="__span-61-1"><a id="__codelineno-61-1" name="__codelineno-61-1" href="#__codelineno-61-1"></a><span class="p">{</span>
</span><span id="__span-61-2"><a id="__codelineno-61-2" name="__codelineno-61-2" href="#__codelineno-61-2"></a><span class="w">  </span><span class="nt">"registry-mirrors"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span id="__span-61-3"><a id="__codelineno-61-3" name="__codelineno-61-3" href="#__codelineno-61-3"></a><span class="w">    </span><span class="s2">"https://hub-mirror.c.163.com"</span><span class="p">,</span>
</span><span id="__span-61-4"><a id="__codelineno-61-4" name="__codelineno-61-4" href="#__codelineno-61-4"></a><span class="w">    </span><span class="s2">"https://mirror.baidubce.com"</span>
</span><span id="__span-61-5"><a id="__codelineno-61-5" name="__codelineno-61-5" href="#__codelineno-61-5"></a><span class="w">  </span><span class="p">],</span>
</span><span id="__span-61-6"><a id="__codelineno-61-6" name="__codelineno-61-6" href="#__codelineno-61-6"></a><span class="w">  </span><span class="nt">"insecure-registries"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span id="__span-61-7"><a id="__codelineno-61-7" name="__codelineno-61-7" href="#__codelineno-61-7"></a><span class="w">    </span><span class="s2">"192.168.199.100:5000"</span>
</span><span id="__span-61-8"><a id="__codelineno-61-8" name="__codelineno-61-8" href="#__codelineno-61-8"></a><span class="w">  </span><span class="p">]</span>
</span><span id="__span-61-9"><a id="__codelineno-61-9" name="__codelineno-61-9" href="#__codelineno-61-9"></a><span class="p">}</span>
</span></code></pre></div> <div class="admonition warning"> <p class="admonition-title">Caution</p> <p>该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p> </div> <p><strong>其他</strong></p> <p>对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 <code>Docker Engine</code> 中进行编辑 ，增加和上边一样的字符串即可。</p> <h2 id="5数据管理">5、数据管理<a class="headerlink" href="#5数据管理" title="锚点链接">¶</a></h2> <p>在容器中管理数据主要有两种方式：</p> <ul> <li>数据卷（Volumes）。</li> <li>绑定挂载 (Bind mounts)。</li> </ul> <p>Docker 管理数据卷的命令为 <code>docker volume</code>，其下有以下子命令：</p> <table> <thead> <tr> <th style="text-align: left;">命令</th> <th style="text-align: left;">描述</th> </tr> </thead> <tbody> <tr> <td style="text-align: left;"><code>docker volume create</code></td> <td style="text-align: left;">创建卷。</td> </tr> <tr> <td style="text-align: left;"><code>docker volume inspect</code></td> <td style="text-align: left;">显示一个或多个卷的详细信息。</td> </tr> <tr> <td style="text-align: left;"><code>docker volume ls</code></td> <td style="text-align: left;">列出卷。</td> </tr> <tr> <td style="text-align: left;"><code>docker volume prune</code></td> <td style="text-align: left;">删除未使用的本地卷。</td> </tr> <tr> <td style="text-align: left;"><code>docker volume rm</code></td> <td style="text-align: left;">删除一个或多个卷。</td> </tr> <tr> <td style="text-align: left;"><code>docker volume update</code></td> <td style="text-align: left;">更新卷（仅限集群卷）。</td> </tr> </tbody> </table> <h3 id="51数据卷">5.1、数据卷<a class="headerlink" href="#51数据卷" title="锚点链接">¶</a></h3> <p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UnionFS，可以提供很多有用的特性：</p> <ul> <li>数据卷可以在容器之间共享和重用。</li> <li>对数据卷的修改会立马生效。</li> <li>对数据卷的更新，不会影响镜像。</li> <li>数据卷默认会一直存在，即使容器被删除。</li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p>数据卷的使用，类似于 Linux 下对目录或文件进行 <code>mount</code>，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p> </div> <h4 id="511创建数据卷">5.1.1、创建数据卷<a class="headerlink" href="#511创建数据卷" title="锚点链接">¶</a></h4> <p>创建数据卷 <code>my-vol</code>：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-62-1"><a id="__codelineno-62-1" name="__codelineno-62-1" href="#__codelineno-62-1"></a>docker<span class="w"> </span>volume<span class="w"> </span>create<span class="w"> </span>my-vol
</span></code></pre></div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>如果未指定名称，Docker 将生成一个随机名称，这种数据卷被称为匿名卷。</p> </div> <p>使用 <code>docker volume ls</code> 查看所有的数据卷：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-63-1"><a id="__codelineno-63-1" name="__codelineno-63-1" href="#__codelineno-63-1"></a>$ docker volume ls
</span><span id="__span-63-2"><a id="__codelineno-63-2" name="__codelineno-63-2" href="#__codelineno-63-2"></a>
</span><span id="__span-63-3"><a id="__codelineno-63-3" name="__codelineno-63-3" href="#__codelineno-63-3"></a>DRIVER              VOLUME NAME
</span><span id="__span-63-4"><a id="__codelineno-63-4" name="__codelineno-63-4" href="#__codelineno-63-4"></a>local               my-vol
</span></code></pre></div> <p>使用 <code>docker volume inspect</code> 命令可以查看指定数据卷的信息：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-64-1"><a id="__codelineno-64-1" name="__codelineno-64-1" href="#__codelineno-64-1"></a>$ docker volume inspect my-vol
</span><span id="__span-64-2"><a id="__codelineno-64-2" name="__codelineno-64-2" href="#__codelineno-64-2"></a>[
</span><span id="__span-64-3"><a id="__codelineno-64-3" name="__codelineno-64-3" href="#__codelineno-64-3"></a>    {
</span><span id="__span-64-4"><a id="__codelineno-64-4" name="__codelineno-64-4" href="#__codelineno-64-4"></a>        "Driver": "local",
</span><span id="__span-64-5"><a id="__codelineno-64-5" name="__codelineno-64-5" href="#__codelineno-64-5"></a>        "Labels": {},
</span><span id="__span-64-6"><a id="__codelineno-64-6" name="__codelineno-64-6" href="#__codelineno-64-6"></a>        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",
</span><span id="__span-64-7"><a id="__codelineno-64-7" name="__codelineno-64-7" href="#__codelineno-64-7"></a>        "Name": "my-vol",
</span><span id="__span-64-8"><a id="__codelineno-64-8" name="__codelineno-64-8" href="#__codelineno-64-8"></a>        "Options": {},
</span><span id="__span-64-9"><a id="__codelineno-64-9" name="__codelineno-64-9" href="#__codelineno-64-9"></a>        "Scope": "local"
</span><span id="__span-64-10"><a id="__codelineno-64-10" name="__codelineno-64-10" href="#__codelineno-64-10"></a>    }
</span><span id="__span-64-11"><a id="__codelineno-64-11" name="__codelineno-64-11" href="#__codelineno-64-11"></a>]
</span></code></pre></div> <h4 id="512使用数据卷启动容器">5.1.2、使用数据卷启动容器<a class="headerlink" href="#512使用数据卷启动容器" title="锚点链接">¶</a></h4> <p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将数据卷挂载到容器里，在一次 <code>docker run</code> 中可以挂载多个数据卷。</p> <p>下面创建一个名为 <code>web</code> 的容器，并加载一个数据卷到容器的 <code>/usr/share/nginx/html</code> 目录：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-65-1"><a id="__codelineno-65-1" name="__codelineno-65-1" href="#__codelineno-65-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>--name<span class="w"> </span>web<span class="w"> </span>--mount<span class="w"> </span><span class="nv">source</span><span class="o">=</span>my-vol,target<span class="o">=</span>/usr/share/nginx/html<span class="w"> </span>nginx:alpine
</span></code></pre></div> <p>使用 <code>docker inspect</code> 命令验证 <code>web</code> 容器是否已正确挂载数据卷：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-66-1"><a id="__codelineno-66-1" name="__codelineno-66-1" href="#__codelineno-66-1"></a>docker<span class="w"> </span>inspect<span class="w"> </span>web
</span></code></pre></div> <p>查找 <code>Mounts</code> 部分：</p> <div class="language-json highlight"><span class="filename">JSON</span><pre><span></span><code><span id="__span-67-1"><a id="__codelineno-67-1" name="__codelineno-67-1" href="#__codelineno-67-1"></a><span class="nt">"Mounts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span id="__span-67-2"><a id="__codelineno-67-2" name="__codelineno-67-2" href="#__codelineno-67-2"></a><span class="w">    </span><span class="p">{</span>
</span><span id="__span-67-3"><a id="__codelineno-67-3" name="__codelineno-67-3" href="#__codelineno-67-3"></a><span class="w">        </span><span class="nt">"Type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"volume"</span><span class="p">,</span>
</span><span id="__span-67-4"><a id="__codelineno-67-4" name="__codelineno-67-4" href="#__codelineno-67-4"></a><span class="w">        </span><span class="nt">"Name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"my-vol"</span><span class="p">,</span>
</span><span id="__span-67-5"><a id="__codelineno-67-5" name="__codelineno-67-5" href="#__codelineno-67-5"></a><span class="w">        </span><span class="nt">"Source"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/var/lib/docker/volumes/my-vol/_data"</span><span class="p">,</span>
</span><span id="__span-67-6"><a id="__codelineno-67-6" name="__codelineno-67-6" href="#__codelineno-67-6"></a><span class="w">        </span><span class="nt">"Destination"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/usr/share/nginx/html"</span><span class="p">,</span>
</span><span id="__span-67-7"><a id="__codelineno-67-7" name="__codelineno-67-7" href="#__codelineno-67-7"></a><span class="w">        </span><span class="nt">"Driver"</span><span class="p">:</span><span class="w"> </span><span class="s2">"local"</span><span class="p">,</span>
</span><span id="__span-67-8"><a id="__codelineno-67-8" name="__codelineno-67-8" href="#__codelineno-67-8"></a><span class="w">        </span><span class="nt">"Mode"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span>
</span><span id="__span-67-9"><a id="__codelineno-67-9" name="__codelineno-67-9" href="#__codelineno-67-9"></a><span class="w">        </span><span class="nt">"RW"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
</span><span id="__span-67-10"><a id="__codelineno-67-10" name="__codelineno-67-10" href="#__codelineno-67-10"></a><span class="w">        </span><span class="nt">"Propagation"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span>
</span><span id="__span-67-11"><a id="__codelineno-67-11" name="__codelineno-67-11" href="#__codelineno-67-11"></a><span class="w">    </span><span class="p">}</span>
</span><span id="__span-67-12"><a id="__codelineno-67-12" name="__codelineno-67-12" href="#__codelineno-67-12"></a><span class="p">],</span>
</span></code></pre></div> <p>这表明数据卷挂载成功，它显示了正确的源和目标，并且挂载是读写的。</p> <h4 id="513删除数据卷">5.1.3、删除数据卷<a class="headerlink" href="#513删除数据卷" title="锚点链接">¶</a></h4> <p>删除数据卷 <code>my-vol</code>：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-68-1"><a id="__codelineno-68-1" name="__codelineno-68-1" href="#__codelineno-68-1"></a>docker<span class="w"> </span>volume<span class="w"> </span>rm<span class="w"> </span>my-vol
</span></code></pre></div> <p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。</p> <p>无主的数据卷可能会占据很多空间，要清理可以使用 <code>docker volume prune</code> 命令。</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p><code>docker volume prune</code> 只会删除所有未被容器使用的匿名卷，如果想删除所有未使用的卷，需要加上参数 <code>-a</code>。</p> </div> <h3 id="52绑定挂载">5.2、绑定挂载<a class="headerlink" href="#52绑定挂载" title="锚点链接">¶</a></h3> <p><strong>挂载主机目录作为数据卷</strong></p> <p>使用 <code>--mount</code> 参数可以指定挂载一个本地主机的目录到容器中去：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-69-1"><a id="__codelineno-69-1" name="__codelineno-69-1" href="#__codelineno-69-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>--name<span class="w"> </span>web<span class="w"> </span>--mount<span class="w"> </span><span class="nv">type</span><span class="o">=</span>bind,source<span class="o">=</span>/src/webapp,target<span class="o">=</span>/usr/share/nginx/html<span class="w"> </span>nginx:alpine
</span></code></pre></div> <p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。</p> <div class="admonition warning"> <p class="admonition-title">Caution</p> <p>使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p> </div> <p>使用 <code>docker inspect</code> 命令验证 <code>web</code> 容器是否已正确挂载数据卷：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-70-1"><a id="__codelineno-70-1" name="__codelineno-70-1" href="#__codelineno-70-1"></a>docker<span class="w"> </span>inspect<span class="w"> </span>web
</span></code></pre></div> <p>查找 <code>Mounts</code> 部分：</p> <div class="language-json highlight"><span class="filename">JSON</span><pre><span></span><code><span id="__span-71-1"><a id="__codelineno-71-1" name="__codelineno-71-1" href="#__codelineno-71-1"></a><span class="nt">"Mounts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span id="__span-71-2"><a id="__codelineno-71-2" name="__codelineno-71-2" href="#__codelineno-71-2"></a><span class="w">    </span><span class="p">{</span>
</span><span id="__span-71-3"><a id="__codelineno-71-3" name="__codelineno-71-3" href="#__codelineno-71-3"></a><span class="w">        </span><span class="nt">"Type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"bind"</span><span class="p">,</span>
</span><span id="__span-71-4"><a id="__codelineno-71-4" name="__codelineno-71-4" href="#__codelineno-71-4"></a><span class="w">        </span><span class="nt">"Source"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/src/webapp"</span><span class="p">,</span>
</span><span id="__span-71-5"><a id="__codelineno-71-5" name="__codelineno-71-5" href="#__codelineno-71-5"></a><span class="w">        </span><span class="nt">"Destination"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/usr/share/nginx/html"</span><span class="p">,</span>
</span><span id="__span-71-6"><a id="__codelineno-71-6" name="__codelineno-71-6" href="#__codelineno-71-6"></a><span class="w">        </span><span class="nt">"Mode"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span>
</span><span id="__span-71-7"><a id="__codelineno-71-7" name="__codelineno-71-7" href="#__codelineno-71-7"></a><span class="w">        </span><span class="nt">"RW"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
</span><span id="__span-71-8"><a id="__codelineno-71-8" name="__codelineno-71-8" href="#__codelineno-71-8"></a><span class="w">        </span><span class="nt">"Propagation"</span><span class="p">:</span><span class="w"> </span><span class="s2">"rprivate"</span>
</span><span id="__span-71-9"><a id="__codelineno-71-9" name="__codelineno-71-9" href="#__codelineno-71-9"></a><span class="w">    </span><span class="p">}</span>
</span><span id="__span-71-10"><a id="__codelineno-71-10" name="__codelineno-71-10" href="#__codelineno-71-10"></a><span class="p">],</span>
</span></code></pre></div> <p>这表明 <code>bind</code> 挂载成功，显示挂载是读写的，，用户也可以通过增加 <code>readonly</code> 指定为只读：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-72-1"><a id="__codelineno-72-1" name="__codelineno-72-1" href="#__codelineno-72-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>--name<span class="w"> </span>web<span class="w"> </span>--mount<span class="w"> </span><span class="nv">type</span><span class="o">=</span>bind,source<span class="o">=</span>/src/webapp,target<span class="o">=</span>/usr/share/nginx/html,readonly<span class="w"> </span>nginx:alpine
</span></code></pre></div> <p>加了 <code>readonly</code> 之后，就挂载为只读了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-73-1"><a id="__codelineno-73-1" name="__codelineno-73-1" href="#__codelineno-73-1"></a>/usr/share/nginx/html # touch new.txt
</span><span id="__span-73-2"><a id="__codelineno-73-2" name="__codelineno-73-2" href="#__codelineno-73-2"></a>touch: new.txt: Read-only file system
</span></code></pre></div> <p><strong>挂载主机文件作为数据卷</strong></p> <p><code>--mount</code> 参数也可以从主机挂载单个文件到容器中：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-74-1"><a id="__codelineno-74-1" name="__codelineno-74-1" href="#__codelineno-74-1"></a>$ docker run --rm -it --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history ubuntu:18.04 bash
</span><span id="__span-74-2"><a id="__codelineno-74-2" name="__codelineno-74-2" href="#__codelineno-74-2"></a>
</span><span id="__span-74-3"><a id="__codelineno-74-3" name="__codelineno-74-3" href="#__codelineno-74-3"></a>root@2affd44b4667:/# history
</span><span id="__span-74-4"><a id="__codelineno-74-4" name="__codelineno-74-4" href="#__codelineno-74-4"></a>1  ls
</span><span id="__span-74-5"><a id="__codelineno-74-5" name="__codelineno-74-5" href="#__codelineno-74-5"></a>2  diskutil list
</span></code></pre></div> <p>这样就可以记录在容器输入过的命令了。</p> <h2 id="6使用网络">6、使用网络<a class="headerlink" href="#6使用网络" title="锚点链接">¶</a></h2> <p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p> <p>Docker 管理网络的命令为 <code>docker network</code>，您可以使用子命令来创建、检查、列出、删除、清理、连接和断开网络。其下有以下子命令：</p> <table> <thead> <tr> <th style="text-align: left;">命令</th> <th style="text-align: left;">描述</th> </tr> </thead> <tbody> <tr> <td style="text-align: left;"><code>docker network connect</code></td> <td style="text-align: left;">将容器连接到网络。</td> </tr> <tr> <td style="text-align: left;"><code>docker network create</code></td> <td style="text-align: left;">创建网络。</td> </tr> <tr> <td style="text-align: left;"><code>docker network disconnect</code></td> <td style="text-align: left;">将容器从网络断开连接。</td> </tr> <tr> <td style="text-align: left;"><code>docker network inspect</code></td> <td style="text-align: left;">显示一个或多个网络的详细信息。</td> </tr> <tr> <td style="text-align: left;"><code>docker network ls</code></td> <td style="text-align: left;">列出网络。</td> </tr> <tr> <td style="text-align: left;"><code>docker network prune</code></td> <td style="text-align: left;">删除所有未使用的网络。</td> </tr> <tr> <td style="text-align: left;"><code>docker network rm</code></td> <td style="text-align: left;">删除一个或多个网络。</td> </tr> </tbody> </table> <h3 id="61外部访问容器">6.1、外部访问容器<a class="headerlink" href="#61外部访问容器" title="锚点链接">¶</a></h3> <p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p> <p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p> <p>使用 <code>docker ps</code> 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 Nginx 默认页面：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-75-1"><a id="__codelineno-75-1" name="__codelineno-75-1" href="#__codelineno-75-1"></a>$ docker run -d -P nginx:alpine
</span><span id="__span-75-2"><a id="__codelineno-75-2" name="__codelineno-75-2" href="#__codelineno-75-2"></a>
</span><span id="__span-75-3"><a id="__codelineno-75-3" name="__codelineno-75-3" href="#__codelineno-75-3"></a>$ docker ps -l
</span><span id="__span-75-4"><a id="__codelineno-75-4" name="__codelineno-75-4" href="#__codelineno-75-4"></a>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
</span><span id="__span-75-5"><a id="__codelineno-75-5" name="__codelineno-75-5" href="#__codelineno-75-5"></a>fae320d08268        nginx:alpine        "/docker-entrypoint.…"   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty
</span></code></pre></div> <p>同样的，可以通过 <code>docker logs</code> 命令来查看访问记录：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-76-1"><a id="__codelineno-76-1" name="__codelineno-76-1" href="#__codelineno-76-1"></a>$ docker logs fae3
</span><span id="__span-76-2"><a id="__codelineno-76-2" name="__codelineno-76-2" href="#__codelineno-76-2"></a>172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0" "-"
</span></code></pre></div> <p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有：</p> <ul> <li><code>hostPort:containerPort</code></li> <li><code>ip:hostPort:containerPort</code></li> <li><code>ip::containerPort</code></li> </ul> <p><strong>映射所有接口地址</strong></p> <p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-77-1"><a id="__codelineno-77-1" name="__codelineno-77-1" href="#__codelineno-77-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>-p<span class="w"> </span><span class="m">80</span>:80<span class="w"> </span>nginx:alpine
</span></code></pre></div> <p>此时默认会绑定本地所有接口上的所有地址。</p> <p><code>-p</code> 标记可以多次使用来绑定多个端口，例如：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-78-1"><a id="__codelineno-78-1" name="__codelineno-78-1" href="#__codelineno-78-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>-p<span class="w"> </span><span class="m">80</span>:80<span class="w"> </span>-p<span class="w"> </span><span class="m">443</span>:443<span class="w"> </span>nginx:alpine
</span></code></pre></div> <p><strong>映射到指定地址的指定端口</strong></p> <p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 <code>localhost</code> 地址 <code>127.0.0.1</code>：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-79-1"><a id="__codelineno-79-1" name="__codelineno-79-1" href="#__codelineno-79-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>-p<span class="w"> </span><span class="m">127</span>.0.0.1:80:80<span class="w"> </span>nginx:alpine
</span></code></pre></div> <p><strong>映射到指定地址的任意端口</strong></p> <p>使用 <code>ip::containerPort</code> 绑定 <code>localhost</code> 的任意端口到容器的 80 端口，本地主机会自动分配一个端口：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-80-1"><a id="__codelineno-80-1" name="__codelineno-80-1" href="#__codelineno-80-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>-p<span class="w"> </span><span class="m">127</span>.0.0.1::80<span class="w"> </span>nginx:alpine
</span></code></pre></div> <p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-81-1"><a id="__codelineno-81-1" name="__codelineno-81-1" href="#__codelineno-81-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>-p<span class="w"> </span><span class="m">127</span>.0.0.1:80:80/udp<span class="w"> </span>nginx:alpine
</span></code></pre></div> <h4 id="611查看映射端口配置">6.1.1、查看映射端口配置<a class="headerlink" href="#611查看映射端口配置" title="锚点链接">¶</a></h4> <p>使用 <code>docker container port</code>（常用别名为 <code>docker port</code>）来查看当前映射的端口配置，也可以查看到绑定的地址：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-82-1"><a id="__codelineno-82-1" name="__codelineno-82-1" href="#__codelineno-82-1"></a>$ docker port fa 80
</span><span id="__span-82-2"><a id="__codelineno-82-2" name="__codelineno-82-2" href="#__codelineno-82-2"></a>0.0.0.0:32768
</span></code></pre></div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>容器有自己的内部网络和 IP 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置）。</p> </div> <h3 id="62容器互联">6.2、容器互联<a class="headerlink" href="#62容器互联" title="锚点链接">¶</a></h3> <p>如果你之前有 <code>Docker</code> 使用经验，你可能已经习惯了使用 <code>--link</code> 参数来使容器互联。</p> <p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。</p> </div> <h4 id="621新建网络">6.2.1、新建网络<a class="headerlink" href="#621新建网络" title="锚点链接">¶</a></h4> <p>下面先创建一个新的 Docker 网络：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-83-1"><a id="__codelineno-83-1" name="__codelineno-83-1" href="#__codelineno-83-1"></a>docker<span class="w"> </span>network<span class="w"> </span>create<span class="w"> </span>-d<span class="w"> </span>bridge<span class="w"> </span>my-net
</span></code></pre></div> <p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code>、<code>overlay</code>。</p> <h4 id="622连接容器">6.2.2、连接容器<a class="headerlink" href="#622连接容器" title="锚点链接">¶</a></h4> <p>运行一个容器并连接到新建的 <code>my-net</code> 网络：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-84-1"><a id="__codelineno-84-1" name="__codelineno-84-1" href="#__codelineno-84-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-it<span class="w"> </span>--rm<span class="w"> </span>--name<span class="w"> </span>busybox1<span class="w"> </span>--network<span class="w"> </span>my-net<span class="w"> </span>busybox<span class="w"> </span>sh
</span></code></pre></div> <p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-85-1"><a id="__codelineno-85-1" name="__codelineno-85-1" href="#__codelineno-85-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-it<span class="w"> </span>--rm<span class="w"> </span>--name<span class="w"> </span>busybox2<span class="w"> </span>--network<span class="w"> </span>my-net<span class="w"> </span>busybox<span class="w"> </span>sh
</span></code></pre></div> <p>再打开一个新的终端查看容器信息：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-86-1"><a id="__codelineno-86-1" name="__codelineno-86-1" href="#__codelineno-86-1"></a>$ docker ps
</span><span id="__span-86-2"><a id="__codelineno-86-2" name="__codelineno-86-2" href="#__codelineno-86-2"></a>
</span><span id="__span-86-3"><a id="__codelineno-86-3" name="__codelineno-86-3" href="#__codelineno-86-3"></a>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</span><span id="__span-86-4"><a id="__codelineno-86-4" name="__codelineno-86-4" href="#__codelineno-86-4"></a>b47060aca56b        busybox             "sh"                11 minutes ago      Up 11 minutes                           busybox2
</span><span id="__span-86-5"><a id="__codelineno-86-5" name="__codelineno-86-5" href="#__codelineno-86-5"></a>8720575823ec        busybox             "sh"                16 minutes ago      Up 16 minutes                           busybox1
</span></code></pre></div> <h4 id="623测试互联">6.2.3、测试互联<a class="headerlink" href="#623测试互联" title="锚点链接">¶</a></h4> <p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p> <p>在 <code>busybox1</code> 容器用 <code>ping busybox2</code> 来测试连接 <code>busybox2</code> 容器：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-87-1"><a id="__codelineno-87-1" name="__codelineno-87-1" href="#__codelineno-87-1"></a>/ # ping busybox2
</span><span id="__span-87-2"><a id="__codelineno-87-2" name="__codelineno-87-2" href="#__codelineno-87-2"></a>PING busybox2 (172.19.0.3): 56 data bytes
</span><span id="__span-87-3"><a id="__codelineno-87-3" name="__codelineno-87-3" href="#__codelineno-87-3"></a>64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms
</span><span id="__span-87-4"><a id="__codelineno-87-4" name="__codelineno-87-4" href="#__codelineno-87-4"></a>64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms
</span></code></pre></div> <p>可以看到它会解析成 <code>172.19.0.3</code>，同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-88-1"><a id="__codelineno-88-1" name="__codelineno-88-1" href="#__codelineno-88-1"></a>/ # ping busybox1
</span><span id="__span-88-2"><a id="__codelineno-88-2" name="__codelineno-88-2" href="#__codelineno-88-2"></a>PING busybox1 (172.19.0.2): 56 data bytes
</span><span id="__span-88-3"><a id="__codelineno-88-3" name="__codelineno-88-3" href="#__codelineno-88-3"></a>64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms
</span><span id="__span-88-4"><a id="__codelineno-88-4" name="__codelineno-88-4" href="#__codelineno-88-4"></a>64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms
</span></code></pre></div> <p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p> <h3 id="63配置-dns">6.3、配置 DNS<a class="headerlink" href="#63配置-dns" title="锚点链接">¶</a></h3> <p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p> <p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-89-1"><a id="__codelineno-89-1" name="__codelineno-89-1" href="#__codelineno-89-1"></a>$ mount
</span><span id="__span-89-2"><a id="__codelineno-89-2" name="__codelineno-89-2" href="#__codelineno-89-2"></a>/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 ...
</span><span id="__span-89-3"><a id="__codelineno-89-3" name="__codelineno-89-3" href="#__codelineno-89-3"></a>/dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...
</span><span id="__span-89-4"><a id="__codelineno-89-4" name="__codelineno-89-4" href="#__codelineno-89-4"></a>tmpfs on /etc/resolv.conf type tmpfs ...
</span></code></pre></div> <p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p> <p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置：</p> <div class="language-json highlight"><span class="filename">JSON</span><pre><span></span><code><span id="__span-90-1"><a id="__codelineno-90-1" name="__codelineno-90-1" href="#__codelineno-90-1"></a><span class="p">{</span>
</span><span id="__span-90-2"><a id="__codelineno-90-2" name="__codelineno-90-2" href="#__codelineno-90-2"></a><span class="w">  </span><span class="nt">"dns"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
</span><span id="__span-90-3"><a id="__codelineno-90-3" name="__codelineno-90-3" href="#__codelineno-90-3"></a><span class="w">    </span><span class="s2">"114.114.114.114"</span><span class="p">,</span>
</span><span id="__span-90-4"><a id="__codelineno-90-4" name="__codelineno-90-4" href="#__codelineno-90-4"></a><span class="w">    </span><span class="s2">"8.8.8.8"</span>
</span><span id="__span-90-5"><a id="__codelineno-90-5" name="__codelineno-90-5" href="#__codelineno-90-5"></a><span class="w">  </span><span class="p">]</span>
</span><span id="__span-90-6"><a id="__codelineno-90-6" name="__codelineno-90-6" href="#__codelineno-90-6"></a><span class="p">}</span>
</span></code></pre></div> <p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用以下命令来证明其已经生效：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-91-1"><a id="__codelineno-91-1" name="__codelineno-91-1" href="#__codelineno-91-1"></a>$ docker run -it --rm ubuntu:18.04 cat /etc/resolv.conf
</span><span id="__span-91-2"><a id="__codelineno-91-2" name="__codelineno-91-2" href="#__codelineno-91-2"></a>
</span><span id="__span-91-3"><a id="__codelineno-91-3" name="__codelineno-91-3" href="#__codelineno-91-3"></a>nameserver 114.114.114.114
</span><span id="__span-91-4"><a id="__codelineno-91-4" name="__codelineno-91-4" href="#__codelineno-91-4"></a>nameserver 8.8.8.8
</span></code></pre></div> <p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p> <ul> <li><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker ps</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</li> <li><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</li> <li><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</li> </ul> <div class="admonition tip"> <p class="admonition-title">Important</p> <p>如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p> </div> <h2 id="7构建镜像">7、构建镜像<a class="headerlink" href="#7构建镜像" title="锚点链接">¶</a></h2> <h3 id="71dockerfile-定制镜像">7.1、Dockerfile 定制镜像<a class="headerlink" href="#71dockerfile-定制镜像" title="锚点链接">¶</a></h3> <p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，这个脚本就是 Dockerfile。</p> <p>Dockerfile 是一个文本文件，其内包含了一条条的指令（Instruction），每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p> <p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-92-1"><a id="__codelineno-92-1" name="__codelineno-92-1" href="#__codelineno-92-1"></a>mkdir<span class="w"> </span>mynginx
</span><span id="__span-92-2"><a id="__codelineno-92-2" name="__codelineno-92-2" href="#__codelineno-92-2"></a><span class="nb">cd</span><span class="w"> </span>mynginx
</span><span id="__span-92-3"><a id="__codelineno-92-3" name="__codelineno-92-3" href="#__codelineno-92-3"></a>touch<span class="w"> </span>Dockerfile
</span></code></pre></div> <p>其内容为：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-93-1"><a id="__codelineno-93-1" name="__codelineno-93-1" href="#__codelineno-93-1"></a><span class="k">FROM</span><span class="w"> </span><span class="s">nginx</span>
</span><span id="__span-93-2"><a id="__codelineno-93-2" name="__codelineno-93-2" href="#__codelineno-93-2"></a><span class="k">RUN</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s1">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span><span class="w"> </span>&gt;<span class="w"> </span>/usr/share/nginx/html/index.html
</span></code></pre></div> <p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p> <h4 id="711from">7.1.1、FROM<a class="headerlink" href="#711from" title="锚点链接">¶</a></h4> <p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。而 <code>FROM</code> 就是指定基础镜像，因此一个 Dockerfile 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p> <p>在 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p> <p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p> <p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-94-1"><a id="__codelineno-94-1" name="__codelineno-94-1" href="#__codelineno-94-1"></a><span class="k">FROM</span><span class="w"> </span><span class="s">scratch</span>
</span><span id="__span-94-2"><a id="__codelineno-94-2" name="__codelineno-94-2" href="#__codelineno-94-2"></a>...
</span></code></pre></div> <p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p> <p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.google.cn/">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p> <h4 id="712run">7.1.2、RUN<a class="headerlink" href="#712run" title="锚点链接">¶</a></h4> <p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。</p> <p>其格式有两种：</p> <ul> <li> <p>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-95-1"><a id="__codelineno-95-1" name="__codelineno-95-1" href="#__codelineno-95-1"></a>RUN<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s1">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span><span class="w"> </span>&gt;<span class="w"> </span>/usr/share/nginx/html/index.html
</span></code></pre></div> </li> <li> <p>exec 格式：<code>RUN ["可执行文件", "参数1", "参数2"]</code>，这更像是函数调用中的格式。</p> </li> </ul> <p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 <code>RUN</code> 呢？比如这样：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-96-1"><a id="__codelineno-96-1" name="__codelineno-96-1" href="#__codelineno-96-1"></a><span class="k">FROM</span><span class="w"> </span><span class="s">debian:stretch</span>
</span><span id="__span-96-2"><a id="__codelineno-96-2" name="__codelineno-96-2" href="#__codelineno-96-2"></a>
</span><span id="__span-96-3"><a id="__codelineno-96-3" name="__codelineno-96-3" href="#__codelineno-96-3"></a><span class="k">RUN</span><span class="w"> </span>apt-get<span class="w"> </span>update
</span><span id="__span-96-4"><a id="__codelineno-96-4" name="__codelineno-96-4" href="#__codelineno-96-4"></a><span class="k">RUN</span><span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>-y<span class="w"> </span>gcc<span class="w"> </span>libc6-dev<span class="w"> </span>make<span class="w"> </span>wget
</span><span id="__span-96-5"><a id="__codelineno-96-5" name="__codelineno-96-5" href="#__codelineno-96-5"></a><span class="k">RUN</span><span class="w"> </span>wget<span class="w"> </span>-O<span class="w"> </span>redis.tar.gz<span class="w"> </span><span class="s2">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span>
</span><span id="__span-96-6"><a id="__codelineno-96-6" name="__codelineno-96-6" href="#__codelineno-96-6"></a><span class="k">RUN</span><span class="w"> </span>mkdir<span class="w"> </span>-p<span class="w"> </span>/usr/src/redis
</span><span id="__span-96-7"><a id="__codelineno-96-7" name="__codelineno-96-7" href="#__codelineno-96-7"></a><span class="k">RUN</span><span class="w"> </span>tar<span class="w"> </span>-xzf<span class="w"> </span>redis.tar.gz<span class="w"> </span>-C<span class="w"> </span>/usr/src/redis<span class="w"> </span>--strip-components<span class="o">=</span><span class="m">1</span>
</span><span id="__span-96-8"><a id="__codelineno-96-8" name="__codelineno-96-8" href="#__codelineno-96-8"></a><span class="k">RUN</span><span class="w"> </span>make<span class="w"> </span>-C<span class="w"> </span>/usr/src/redis
</span><span id="__span-96-9"><a id="__codelineno-96-9" name="__codelineno-96-9" href="#__codelineno-96-9"></a><span class="k">RUN</span><span class="w"> </span>make<span class="w"> </span>-C<span class="w"> </span>/usr/src/redis<span class="w"> </span>install
</span></code></pre></div> <p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p> <p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p> </div> <p>上面的 Dockerfile 正确的写法应该是这样：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-97-1"><a id="__codelineno-97-1" name="__codelineno-97-1" href="#__codelineno-97-1"></a><span class="k">FROM</span><span class="w"> </span><span class="s">debian:stretch</span>
</span><span id="__span-97-2"><a id="__codelineno-97-2" name="__codelineno-97-2" href="#__codelineno-97-2"></a>
</span><span id="__span-97-3"><a id="__codelineno-97-3" name="__codelineno-97-3" href="#__codelineno-97-3"></a><span class="k">RUN</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>-x<span class="p">;</span><span class="w"> </span><span class="nv">buildDeps</span><span class="o">=</span><span class="s1">'gcc libc6-dev make wget'</span><span class="w"> </span><span class="se">\</span>
</span><span id="__span-97-4"><a id="__codelineno-97-4" name="__codelineno-97-4" href="#__codelineno-97-4"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>apt-get<span class="w"> </span>update<span class="w"> </span><span class="se">\</span>
</span><span id="__span-97-5"><a id="__codelineno-97-5" name="__codelineno-97-5" href="#__codelineno-97-5"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>-y<span class="w"> </span><span class="nv">$buildDeps</span><span class="w"> </span><span class="se">\</span>
</span><span id="__span-97-6"><a id="__codelineno-97-6" name="__codelineno-97-6" href="#__codelineno-97-6"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>wget<span class="w"> </span>-O<span class="w"> </span>redis.tar.gz<span class="w"> </span><span class="s2">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span><span class="w"> </span><span class="se">\</span>
</span><span id="__span-97-7"><a id="__codelineno-97-7" name="__codelineno-97-7" href="#__codelineno-97-7"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>mkdir<span class="w"> </span>-p<span class="w"> </span>/usr/src/redis<span class="w"> </span><span class="se">\</span>
</span><span id="__span-97-8"><a id="__codelineno-97-8" name="__codelineno-97-8" href="#__codelineno-97-8"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>tar<span class="w"> </span>-xzf<span class="w"> </span>redis.tar.gz<span class="w"> </span>-C<span class="w"> </span>/usr/src/redis<span class="w"> </span>--strip-components<span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="se">\</span>
</span><span id="__span-97-9"><a id="__codelineno-97-9" name="__codelineno-97-9" href="#__codelineno-97-9"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>make<span class="w"> </span>-C<span class="w"> </span>/usr/src/redis<span class="w"> </span><span class="se">\</span>
</span><span id="__span-97-10"><a id="__codelineno-97-10" name="__codelineno-97-10" href="#__codelineno-97-10"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>make<span class="w"> </span>-C<span class="w"> </span>/usr/src/redis<span class="w"> </span>install<span class="w"> </span><span class="se">\</span>
</span><span id="__span-97-11"><a id="__codelineno-97-11" name="__codelineno-97-11" href="#__codelineno-97-11"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>rm<span class="w"> </span>-rf<span class="w"> </span>/var/lib/apt/lists/*<span class="w"> </span><span class="se">\</span>
</span><span id="__span-97-12"><a id="__codelineno-97-12" name="__codelineno-97-12" href="#__codelineno-97-12"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>rm<span class="w"> </span>redis.tar.gz<span class="w"> </span><span class="se">\</span>
</span><span id="__span-97-13"><a id="__codelineno-97-13" name="__codelineno-97-13" href="#__codelineno-97-13"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>rm<span class="w"> </span>-r<span class="w"> </span>/usr/src/redis<span class="w"> </span><span class="se">\</span>
</span><span id="__span-97-14"><a id="__codelineno-97-14" name="__codelineno-97-14" href="#__codelineno-97-14"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>apt-get<span class="w"> </span>purge<span class="w"> </span>-y<span class="w"> </span>--auto-remove<span class="w"> </span><span class="nv">$buildDeps</span>
</span></code></pre></div> <p>首先，之前所有的命令只有一个目的，就是编译、安装 Redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p> <p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p> <p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p> <p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p> <h4 id="713构建镜像">7.1.3、构建镜像<a class="headerlink" href="#713构建镜像" title="锚点链接">¶</a></h4> <p>在 Dockerfile 文件所在目录执行命令开始构建镜像：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-98-1"><a id="__codelineno-98-1" name="__codelineno-98-1" href="#__codelineno-98-1"></a>$<span class="w"> </span>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>nginx:v3<span class="w"> </span>.
</span><span id="__span-98-2"><a id="__codelineno-98-2" name="__codelineno-98-2" href="#__codelineno-98-2"></a>Sending<span class="w"> </span>build<span class="w"> </span>context<span class="w"> </span>to<span class="w"> </span>Docker<span class="w"> </span>daemon<span class="w"> </span><span class="m">2</span>.048<span class="w"> </span>kB
</span><span id="__span-98-3"><a id="__codelineno-98-3" name="__codelineno-98-3" href="#__codelineno-98-3"></a>Step<span class="w"> </span><span class="m">1</span><span class="w"> </span>:<span class="w"> </span>FROM<span class="w"> </span>nginx
</span><span id="__span-98-4"><a id="__codelineno-98-4" name="__codelineno-98-4" href="#__codelineno-98-4"></a><span class="w"> </span>---&gt;<span class="w"> </span>e43d811ce2f4
</span><span id="__span-98-5"><a id="__codelineno-98-5" name="__codelineno-98-5" href="#__codelineno-98-5"></a>Step<span class="w"> </span><span class="m">2</span><span class="w"> </span>:<span class="w"> </span>RUN<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s1">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span><span class="w"> </span>&gt;<span class="w"> </span>/usr/share/nginx/html/index.html
</span><span id="__span-98-6"><a id="__codelineno-98-6" name="__codelineno-98-6" href="#__codelineno-98-6"></a><span class="w"> </span>---&gt;<span class="w"> </span>Running<span class="w"> </span><span class="k">in</span><span class="w"> </span>9cdc27646c7b
</span><span id="__span-98-7"><a id="__codelineno-98-7" name="__codelineno-98-7" href="#__codelineno-98-7"></a><span class="w"> </span>---&gt;<span class="w"> </span>44aa4490ce2c
</span><span id="__span-98-8"><a id="__codelineno-98-8" name="__codelineno-98-8" href="#__codelineno-98-8"></a>Removing<span class="w"> </span>intermediate<span class="w"> </span>container<span class="w"> </span>9cdc27646c7b
</span><span id="__span-98-9"><a id="__codelineno-98-9" name="__codelineno-98-9" href="#__codelineno-98-9"></a>Successfully<span class="w"> </span>built<span class="w"> </span>44aa4490ce2c
</span></code></pre></div> <p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p> <p>这里我们使用了 <code>docker image build</code> 命令（常用别名为 <code>docker build</code>）进行镜像构建。其格式为：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-99-1"><a id="__codelineno-99-1" name="__codelineno-99-1" href="#__codelineno-99-1"></a>docker<span class="w"> </span>build<span class="w"> </span><span class="o">[</span>选项<span class="o">]</span><span class="w"> </span>&lt;上下文路径/URL/-&gt;
</span></code></pre></div> <p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p> <h4 id="714镜像构建上下文">7.1.4、镜像构建上下文<a class="headerlink" href="#714镜像构建上下文" title="锚点链接">¶</a></h4> <p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。</p> <p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p> <p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p> <p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p> <p>如果在 Dockerfile 中这么写：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-100-1"><a id="__codelineno-100-1" name="__codelineno-100-1" href="#__codelineno-100-1"></a>COPY<span class="w"> </span>./package.json<span class="w"> </span>/app/
</span></code></pre></div> <p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 Dockerfile 所在目录下的 <code>package.json</code>，而是复制上下文（context） 目录下的 <code>package.json</code>。</p> <p>因此，<code>COPY</code> 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p> <p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p> <p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-101-1"><a id="__codelineno-101-1" name="__codelineno-101-1" href="#__codelineno-101-1"></a>$<span class="w"> </span>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>nginx:v3<span class="w"> </span>.
</span><span id="__span-101-2"><a id="__codelineno-101-2" name="__codelineno-101-2" href="#__codelineno-101-2"></a>Sending<span class="w"> </span>build<span class="w"> </span>context<span class="w"> </span>to<span class="w"> </span>Docker<span class="w"> </span>daemon<span class="w"> </span><span class="m">2</span>.048<span class="w"> </span>kB
</span><span id="__span-101-3"><a id="__codelineno-101-3" name="__codelineno-101-3" href="#__codelineno-101-3"></a>...
</span></code></pre></div> <p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p> <p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p> <p>那么为什么会有人误以为 <code>.</code> 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p> <p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 Dockerfile。</p> <p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p> <h4 id="715build-的其它用法">7.1.5、build 的其它用法<a class="headerlink" href="#715build-的其它用法" title="锚点链接">¶</a></h4> <p><strong>直接用 Git repo 进行构建</strong></p> <p><code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-102-1"><a id="__codelineno-102-1" name="__codelineno-102-1" href="#__codelineno-102-1"></a><span class="c1">## $env:DOCKER_BUILDKIT=0</span>
</span><span id="__span-102-2"><a id="__codelineno-102-2" name="__codelineno-102-2" href="#__codelineno-102-2"></a><span class="c1">## export DOCKER_BUILDKIT=0</span>
</span><span id="__span-102-3"><a id="__codelineno-102-3" name="__codelineno-102-3" href="#__codelineno-102-3"></a>
</span><span id="__span-102-4"><a id="__codelineno-102-4" name="__codelineno-102-4" href="#__codelineno-102-4"></a>$<span class="w"> </span>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>hello-world<span class="w"> </span>https://github.com/docker-library/hello-world.git#master:amd64/hello-world
</span><span id="__span-102-5"><a id="__codelineno-102-5" name="__codelineno-102-5" href="#__codelineno-102-5"></a>
</span><span id="__span-102-6"><a id="__codelineno-102-6" name="__codelineno-102-6" href="#__codelineno-102-6"></a>Step<span class="w"> </span><span class="m">1</span>/3<span class="w"> </span>:<span class="w"> </span>FROM<span class="w"> </span>scratch
</span><span id="__span-102-7"><a id="__codelineno-102-7" name="__codelineno-102-7" href="#__codelineno-102-7"></a><span class="w"> </span>---&gt;
</span><span id="__span-102-8"><a id="__codelineno-102-8" name="__codelineno-102-8" href="#__codelineno-102-8"></a>Step<span class="w"> </span><span class="m">2</span>/3<span class="w"> </span>:<span class="w"> </span>COPY<span class="w"> </span>hello<span class="w"> </span>/
</span><span id="__span-102-9"><a id="__codelineno-102-9" name="__codelineno-102-9" href="#__codelineno-102-9"></a><span class="w"> </span>---&gt;<span class="w"> </span>ac779757d46e
</span><span id="__span-102-10"><a id="__codelineno-102-10" name="__codelineno-102-10" href="#__codelineno-102-10"></a>Step<span class="w"> </span><span class="m">3</span>/3<span class="w"> </span>:<span class="w"> </span>CMD<span class="w"> </span><span class="o">[</span><span class="s2">"/hello"</span><span class="o">]</span>
</span><span id="__span-102-11"><a id="__codelineno-102-11" name="__codelineno-102-11" href="#__codelineno-102-11"></a><span class="w"> </span>---&gt;<span class="w"> </span>Running<span class="w"> </span><span class="k">in</span><span class="w"> </span>d2a513a760ed
</span><span id="__span-102-12"><a id="__codelineno-102-12" name="__codelineno-102-12" href="#__codelineno-102-12"></a>Removing<span class="w"> </span>intermediate<span class="w"> </span>container<span class="w"> </span>d2a513a760ed
</span><span id="__span-102-13"><a id="__codelineno-102-13" name="__codelineno-102-13" href="#__codelineno-102-13"></a><span class="w"> </span>---&gt;<span class="w"> </span>038ad4142d2b
</span><span id="__span-102-14"><a id="__codelineno-102-14" name="__codelineno-102-14" href="#__codelineno-102-14"></a>Successfully<span class="w"> </span>built<span class="w"> </span>038ad4142d2b
</span></code></pre></div> <p>这行命令指定了构建所需的 Git repo，并且指定分支为 <code>master</code>，构建目录为 <code>/amd64/hello-world/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p> <p><strong>用给定的 tar 压缩包构建</strong></p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-103-1"><a id="__codelineno-103-1" name="__codelineno-103-1" href="#__codelineno-103-1"></a>docker<span class="w"> </span>build<span class="w"> </span>http://server/context.tar.gz
</span></code></pre></div> <p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p> <p><strong>从标准输入中读取 Dockerfile 进行构建</strong></p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-104-1"><a id="__codelineno-104-1" name="__codelineno-104-1" href="#__codelineno-104-1"></a>docker<span class="w"> </span>build<span class="w"> </span>-<span class="w"> </span>&lt;<span class="w"> </span>Dockerfile
</span></code></pre></div> <p>或</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-105-1"><a id="__codelineno-105-1" name="__codelineno-105-1" href="#__codelineno-105-1"></a>cat<span class="w"> </span>Dockerfile<span class="w"> </span><span class="p">|</span><span class="w"> </span>docker<span class="w"> </span>build<span class="w"> </span>-
</span></code></pre></div> <p>如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p> <p><strong>从标准输入中读取上下文压缩包进行构建</strong></p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-106-1"><a id="__codelineno-106-1" name="__codelineno-106-1" href="#__codelineno-106-1"></a>docker<span class="w"> </span>build<span class="w"> </span>-<span class="w"> </span>&lt;<span class="w"> </span>context.tar.gz
</span></code></pre></div> <p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p> <h3 id="72dockerfile-指令详解">7.2、Dockerfile 指令详解<a class="headerlink" href="#72dockerfile-指令详解" title="锚点链接">¶</a></h3> <p>其实 Dockerfile 功能很强大，除了 <code>FROM</code> 和 <code>RUN</code>,它提供了十多个指令。</p> <h4 id="721copy">7.2.1、COPY<a class="headerlink" href="#721copy" title="锚点链接">¶</a></h4> <p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。</p> <p>格式有两种：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-107-1"><a id="__codelineno-107-1" name="__codelineno-107-1" href="#__codelineno-107-1"></a><span class="k">COPY</span><span class="w"> </span><span class="o">[</span>--chown<span class="o">=</span>&lt;user&gt;:&lt;group&gt;<span class="o">]</span><span class="w"> </span>&lt;源路径&gt;...<span class="w"> </span>&lt;目标路径&gt;
</span><span id="__span-107-2"><a id="__codelineno-107-2" name="__codelineno-107-2" href="#__codelineno-107-2"></a><span class="k">COPY</span><span class="w"> </span><span class="o">[</span>--chown<span class="o">=</span>&lt;user&gt;:&lt;group&gt;<span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="s2">"&lt;源路径1&gt;"</span>,...<span class="w"> </span><span class="s2">"&lt;目标路径&gt;"</span><span class="o">]</span>
</span></code></pre></div> <p>和 <code>RUN</code> 指令一样，<code>COPY</code> 也有两种格式，一种类似于命令行，一种类似于函数调用。</p> <p>下面是个简单的示例：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-108-1"><a id="__codelineno-108-1" name="__codelineno-108-1" href="#__codelineno-108-1"></a><span class="k">COPY</span><span class="w"> </span>package.json<span class="w"> </span>/usr/src/app/
</span></code></pre></div> <p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 规则，如：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-109-1"><a id="__codelineno-109-1" name="__codelineno-109-1" href="#__codelineno-109-1"></a><span class="k">COPY</span><span class="w"> </span>hom*<span class="w"> </span>/mydir/
</span><span id="__span-109-2"><a id="__codelineno-109-2" name="__codelineno-109-2" href="#__codelineno-109-2"></a><span class="k">COPY</span><span class="w"> </span>hom?.txt<span class="w"> </span>/mydir/
</span></code></pre></div> <p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p> <p>此外，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p> <p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-110-1"><a id="__codelineno-110-1" name="__codelineno-110-1" href="#__codelineno-110-1"></a><span class="k">COPY</span><span class="w"> </span>--chown<span class="o">=</span><span class="m">55</span>:mygroup<span class="w"> </span>files*<span class="w"> </span>/mydir/
</span><span id="__span-110-2"><a id="__codelineno-110-2" name="__codelineno-110-2" href="#__codelineno-110-2"></a><span class="k">COPY</span><span class="w"> </span>--chown<span class="o">=</span>bin<span class="w"> </span>files*<span class="w"> </span>/mydir/
</span><span id="__span-110-3"><a id="__codelineno-110-3" name="__codelineno-110-3" href="#__codelineno-110-3"></a><span class="k">COPY</span><span class="w"> </span>--chown<span class="o">=</span><span class="m">1</span><span class="w"> </span>files*<span class="w"> </span>/mydir/
</span><span id="__span-110-4"><a id="__codelineno-110-4" name="__codelineno-110-4" href="#__codelineno-110-4"></a><span class="k">COPY</span><span class="w"> </span>--chown<span class="o">=</span><span class="m">10</span>:11<span class="w"> </span>files*<span class="w"> </span>/mydir/
</span></code></pre></div> <p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p> <h4 id="722add">7.2.2、ADD<a class="headerlink" href="#722add" title="锚点链接">¶</a></h4> <p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p> <p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p> <p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p> <p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-111-1"><a id="__codelineno-111-1" name="__codelineno-111-1" href="#__codelineno-111-1"></a><span class="k">FROM</span><span class="w"> </span><span class="s">scratch</span>
</span><span id="__span-111-2"><a id="__codelineno-111-2" name="__codelineno-111-2" href="#__codelineno-111-2"></a><span class="k">ADD</span><span class="w"> </span>ubuntu-xenial-core-cloudimg-amd64-root.tar.gz<span class="w"> </span>/
</span><span id="__span-111-3"><a id="__codelineno-111-3" name="__codelineno-111-3" href="#__codelineno-111-3"></a>...
</span></code></pre></div> <p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p> <p>在 Docker 官方的 <a href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p> <p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p> <p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p> <p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-112-1"><a id="__codelineno-112-1" name="__codelineno-112-1" href="#__codelineno-112-1"></a><span class="k">ADD</span><span class="w"> </span>--chown<span class="o">=</span><span class="m">55</span>:mygroup<span class="w"> </span>files*<span class="w"> </span>/mydir/
</span><span id="__span-112-2"><a id="__codelineno-112-2" name="__codelineno-112-2" href="#__codelineno-112-2"></a><span class="k">ADD</span><span class="w"> </span>--chown<span class="o">=</span>bin<span class="w"> </span>files*<span class="w"> </span>/mydir/
</span><span id="__span-112-3"><a id="__codelineno-112-3" name="__codelineno-112-3" href="#__codelineno-112-3"></a><span class="k">ADD</span><span class="w"> </span>--chown<span class="o">=</span><span class="m">1</span><span class="w"> </span>files*<span class="w"> </span>/mydir/
</span><span id="__span-112-4"><a id="__codelineno-112-4" name="__codelineno-112-4" href="#__codelineno-112-4"></a><span class="k">ADD</span><span class="w"> </span>--chown<span class="o">=</span><span class="m">10</span>:11<span class="w"> </span>files*<span class="w"> </span>/mydir/
</span></code></pre></div> <h4 id="723cmd">7.2.3、CMD<a class="headerlink" href="#723cmd" title="锚点链接">¶</a></h4> <p>Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令。</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>CMD</code> 设置的默认命令可以在容器运行时指定新的命令来替代，比如 <code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p> </div> <p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p> <ul> <li> <p>shell 格式：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-113-1"><a id="__codelineno-113-1" name="__codelineno-113-1" href="#__codelineno-113-1"></a><span class="k">CMD</span><span class="w"> </span>&lt;命令&gt;
</span></code></pre></div> </li> <li> <p>exec 格式：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-114-1"><a id="__codelineno-114-1" name="__codelineno-114-1" href="#__codelineno-114-1"></a><span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">"可执行文件"</span><span class="p">,</span><span class="w"> </span><span class="s2">"参数1"</span><span class="p">,</span><span class="w"> </span><span class="s2">"参数2"</span><span class="err">...</span><span class="p">]</span>
</span></code></pre></div> </li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p>在指定了 <code>ENTRYPOINT</code> 指令后，可以用 <code>CMD</code> 指定默认参数：<code>CMD ["参数1", "参数2"...]</code>。</p> </div> <p>在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>"</code>，而不要使用单引号。</p> <p>如果使用 shell 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-115-1"><a id="__codelineno-115-1" name="__codelineno-115-1" href="#__codelineno-115-1"></a><span class="k">CMD</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$HOME</span>
</span></code></pre></div> <p>在实际执行中，会将其变更为：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-116-1"><a id="__codelineno-116-1" name="__codelineno-116-1" href="#__codelineno-116-1"></a><span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">"sh"</span><span class="p">,</span><span class="w"> </span><span class="s2">"-c"</span><span class="p">,</span><span class="w"> </span><span class="s2">"echo $HOME"</span><span class="w"> </span><span class="p">]</span>
</span></code></pre></div> <p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p> <p><strong>容器中应用在前台执行和后台执行的问题</strong></p> <p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p> <p>一些初学者将 <code>CMD</code> 写为：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-117-1"><a id="__codelineno-117-1" name="__codelineno-117-1" href="#__codelineno-117-1"></a><span class="k">CMD</span><span class="w"> </span>service<span class="w"> </span>nginx<span class="w"> </span>start
</span></code></pre></div> <p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p> <p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p> <p>而使用 <code>service nginx start</code> 命令，则是希望 init 系统以后台守护进程的形式启动 nginx 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ "sh", "-c", "service nginx start"]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p> <p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-118-1"><a id="__codelineno-118-1" name="__codelineno-118-1" href="#__codelineno-118-1"></a><span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">"nginx"</span><span class="p">,</span><span class="w"> </span><span class="s2">"-g"</span><span class="p">,</span><span class="w"> </span><span class="s2">"daemon off;"</span><span class="p">]</span>
</span></code></pre></div> <h4 id="724entrypoint">7.2.4、ENTRYPOINT<a class="headerlink" href="#724entrypoint" title="锚点链接">¶</a></h4> <p><code>ENTRYPOINT</code> 的主要目的是将容器配置为像一个可执行文件。当你设置了 <code>ENTRYPOINT</code>，容器启动时执行的就是这个命令，并且 <code>docker run</code> 命令行中跟在镜像名后面的所有内容都会被当作参数传递给 <code>ENTRYPOINT</code>。</p> <p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 exec 格式和 shell 格式。</p> <p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-119-1"><a id="__codelineno-119-1" name="__codelineno-119-1" href="#__codelineno-119-1"></a>&lt;ENTRYPOINT&gt;<span class="w"> </span><span class="s2">"&lt;CMD&gt;"</span>
</span></code></pre></div> <p><strong>有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code>？</strong></p> <p>答案在于它们不同的设计哲学和使用场景：</p> <table> <thead> <tr> <th>特性/目的</th> <th>CMD</th> <th>ENTRYPOINT</th> </tr> </thead> <tbody> <tr> <td>核心角色</td> <td>提供默认行为，易于被覆盖</td> <td>定义容器的固定入口，不易被覆盖</td> </tr> <tr> <td>如何覆盖</td> <td>在 <code>docker run</code> 后面直接加新命令即可</td> <td>需要使用 <code>--entrypoint</code> 标志，操作更繁琐</td> </tr> <tr> <td>使用场景</td> <td>为开发或调试提供一个默认命令</td> <td>创建一个行为像单一应用程序的镜像</td> </tr> <tr> <td>组合使用</td> <td>作为 <code>ENTRYPOINT</code> 的默认参数</td> <td>作为主命令，接收 <code>CMD</code> 或命令行参数</td> </tr> </tbody> </table> <p>根本区别在于 “是否容易被覆盖” 以及 “设计意图”：</p> <ul> <li> <p><code>CMD</code> 的设计意图是：“这是容器启动时默认要做的事，但你可以轻松地让它做别的。”</p> <p>例如：一个 ubuntu 镜像，<code>CMD ["bash"]</code> 让你默认进入一个 shell，但你也可以用 <code>docker run ubuntu python my_script.py</code> 来运行一个 Python 脚本。</p> </li> <li> <p><code>ENTRYPOINT</code> 的设计意图是：“这个容器就是一个 X 程序，你只能给它传递参数，而不是替换它。”</p> <p>例如：一个 redis 镜像，它的 <code>ENTRYPOINT</code> 就是 <code>redis-server</code>。你启动它就是为了运行 Redis，你可能会传递一个自定义配置文件的路径作为参数，但你不会想把 <code>redis-server</code> 换成 <code>ls -l</code>。</p> </li> </ul> <p><strong>这种 <code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code> 有什么好处？</strong></p> <p>假设我们要创建一个可以 <code>ping</code> 任何主机的容器，但默认 <code>ping</code> 本地主机 <code>localhost</code>。</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-120-1"><a id="__codelineno-120-1" name="__codelineno-120-1" href="#__codelineno-120-1"></a><span class="k">FROM</span><span class="w"> </span><span class="s">ubuntu</span>
</span><span id="__span-120-2"><a id="__codelineno-120-2" name="__codelineno-120-2" href="#__codelineno-120-2"></a><span class="k">RUN</span><span class="w"> </span>apt-get<span class="w"> </span>update<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>-y<span class="w"> </span>iputils-ping
</span><span id="__span-120-3"><a id="__codelineno-120-3" name="__codelineno-120-3" href="#__codelineno-120-3"></a>
</span><span id="__span-120-4"><a id="__codelineno-120-4" name="__codelineno-120-4" href="#__codelineno-120-4"></a><span class="c">## 1. 定义固定的主命令</span>
</span><span id="__span-120-5"><a id="__codelineno-120-5" name="__codelineno-120-5" href="#__codelineno-120-5"></a><span class="k">ENTRYPOINT</span><span class="w"> </span><span class="p">[</span><span class="s2">"ping"</span><span class="p">,</span><span class="w"> </span><span class="s2">"-c"</span><span class="p">,</span><span class="w"> </span><span class="s2">"4"</span><span class="p">]</span>
</span><span id="__span-120-6"><a id="__codelineno-120-6" name="__codelineno-120-6" href="#__codelineno-120-6"></a>
</span><span id="__span-120-7"><a id="__codelineno-120-7" name="__codelineno-120-7" href="#__codelineno-120-7"></a><span class="c">## 2. 提供默认参数</span>
</span><span id="__span-120-8"><a id="__codelineno-120-8" name="__codelineno-120-8" href="#__codelineno-120-8"></a><span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">"localhost"</span><span class="p">]</span>
</span></code></pre></div> <p>现在我们来构建并运行这个镜像（my-pro-ping）：</p> <ul> <li> <p>场景一：不提供任何参数</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-121-1"><a id="__codelineno-121-1" name="__codelineno-121-1" href="#__codelineno-121-1"></a>docker<span class="w"> </span>run<span class="w"> </span>my-pro-ping
</span></code></pre></div> <p><code>CMD</code> 的值 <code>["localhost"]</code> 会被追加到 <code>ENTRYPOINT</code> 后面。实际执行：<code>ping -c 4 localhost</code>。</p> </li> <li> <p>场景二：提供一个新的参数</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-122-1"><a id="__codelineno-122-1" name="__codelineno-122-1" href="#__codelineno-122-1"></a>docker<span class="w"> </span>run<span class="w"> </span>my-pro-ping<span class="w"> </span>google.com
</span></code></pre></div> <p><code>docker run</code> 后面的 <code>google.com</code> 会覆盖掉 <code>CMD</code> 的内容。实际执行：<code>ping -c 4 google.com</code>。</p> </li> <li> <p>场景三：提供多个新参数</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-123-1"><a id="__codelineno-123-1" name="__codelineno-123-1" href="#__codelineno-123-1"></a>docker<span class="w"> </span>run<span class="w"> </span>my-pro-ping<span class="w"> </span>-W<span class="w"> </span><span class="m">5</span><span class="w"> </span>baidu.com
</span></code></pre></div> <p><code>-W 5 baidu.com</code> 会覆盖 <code>CMD</code>。实际执行：<code>ping -c 4 -W 5 baidu.com</code>。</p> </li> </ul> <p>通过这种组合，我们创建了一个非常强大且灵活的镜像：</p> <ul> <li>它明确地表示自己是一个 <code>ping</code> 工具（<code>ENTRYPOINT</code>）。</li> <li>它有合理的默认行为（<code>ping localhost</code>），可以直接运行（<code>CMD</code>）。</li> <li>它又可以非常方便地接受用户自定义的参数，来改变其行为（覆盖 <code>CMD</code>）。</li> </ul> <p>总结：</p> <ul> <li>单独使用 <code>CMD</code>：适用于通用镜像，希望用户可以轻松运行任何命令的场景（如基础操作系统镜像）。</li> <li>单独使用 <code>ENTRYPOINT</code>：适用于创建一个功能非常固定的 "工具型" 容器，但需要用户总是提供参数。</li> <li><code>ENTRYPOINT</code>+<code>CMD</code> 组合：适用于创建应用程序镜像。<code>ENTRYPOINT</code> 定义了应用本身，<code>CMD</code> 定义了应用的默认参数，这使得镜像既稳定又灵活。</li> </ul> <h4 id="725env">7.2.5、ENV<a class="headerlink" href="#725env" title="锚点链接">¶</a></h4> <p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p> <p>格式有两种：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-124-1"><a id="__codelineno-124-1" name="__codelineno-124-1" href="#__codelineno-124-1"></a><span class="k">ENV</span><span class="w"> </span>&lt;key&gt;<span class="w"> </span>&lt;value&gt;
</span><span id="__span-124-2"><a id="__codelineno-124-2" name="__codelineno-124-2" href="#__codelineno-124-2"></a><span class="k">ENV</span><span class="w"> </span>&lt;key1&gt;<span class="o">=</span>&lt;value1&gt;<span class="w"> </span>&lt;key2&gt;<span class="o">=</span>&lt;value2&gt;...
</span></code></pre></div> <p>下面是个简单的示例：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-125-1"><a id="__codelineno-125-1" name="__codelineno-125-1" href="#__codelineno-125-1"></a><span class="k">ENV</span><span class="w"> </span><span class="nv">VERSION</span><span class="o">=</span><span class="m">1</span>.0<span class="w"> </span><span class="nv">DEBUG</span><span class="o">=</span>on<span class="w"> </span><span class="se">\</span>
</span><span id="__span-125-2"><a id="__codelineno-125-2" name="__codelineno-125-2" href="#__codelineno-125-2"></a><span class="w">    </span><span class="nv">NAME</span><span class="o">=</span><span class="s2">"Happy Feet"</span>
</span></code></pre></div> <p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 中的行为是一致的。</p> <p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 Dockerfile 中，就有类似这样的代码：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-126-1"><a id="__codelineno-126-1" name="__codelineno-126-1" href="#__codelineno-126-1"></a><span class="k">ENV</span><span class="w"> </span>NODE_VERSION<span class="w"> </span><span class="m">7</span>.2.0
</span><span id="__span-126-2"><a id="__codelineno-126-2" name="__codelineno-126-2" href="#__codelineno-126-2"></a>
</span><span id="__span-126-3"><a id="__codelineno-126-3" name="__codelineno-126-3" href="#__codelineno-126-3"></a><span class="k">RUN</span><span class="w"> </span>curl<span class="w"> </span>-SLO<span class="w"> </span><span class="s2">"https://nodejs.org/dist/v</span><span class="nv">$NODE_VERSION</span><span class="s2">/node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz"</span><span class="w"> </span><span class="se">\</span>
</span><span id="__span-126-4"><a id="__codelineno-126-4" name="__codelineno-126-4" href="#__codelineno-126-4"></a><span class="w">  </span><span class="o">&amp;&amp;</span><span class="w"> </span>curl<span class="w"> </span>-SLO<span class="w"> </span><span class="s2">"https://nodejs.org/dist/v</span><span class="nv">$NODE_VERSION</span><span class="s2">/SHASUMS256.txt.asc"</span><span class="w"> </span><span class="se">\</span>
</span><span id="__span-126-5"><a id="__codelineno-126-5" name="__codelineno-126-5" href="#__codelineno-126-5"></a><span class="w">  </span><span class="o">&amp;&amp;</span><span class="w"> </span>gpg<span class="w"> </span>--batch<span class="w"> </span>--decrypt<span class="w"> </span>--output<span class="w"> </span>SHASUMS256.txt<span class="w"> </span>SHASUMS256.txt.asc<span class="w"> </span><span class="se">\</span>
</span><span id="__span-126-6"><a id="__codelineno-126-6" name="__codelineno-126-6" href="#__codelineno-126-6"></a><span class="w">  </span><span class="o">&amp;&amp;</span><span class="w"> </span>grep<span class="w"> </span><span class="s2">" node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz\$"</span><span class="w"> </span>SHASUMS256.txt<span class="w"> </span><span class="p">|</span><span class="w"> </span>sha256sum<span class="w"> </span>-c<span class="w"> </span>-<span class="w"> </span><span class="se">\</span>
</span><span id="__span-126-7"><a id="__codelineno-126-7" name="__codelineno-126-7" href="#__codelineno-126-7"></a><span class="w">  </span><span class="o">&amp;&amp;</span><span class="w"> </span>tar<span class="w"> </span>-xJf<span class="w"> </span><span class="s2">"node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz"</span><span class="w"> </span>-C<span class="w"> </span>/usr/local<span class="w"> </span>--strip-components<span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="se">\</span>
</span><span id="__span-126-8"><a id="__codelineno-126-8" name="__codelineno-126-8" href="#__codelineno-126-8"></a><span class="w">  </span><span class="o">&amp;&amp;</span><span class="w"> </span>rm<span class="w"> </span><span class="s2">"node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz"</span><span class="w"> </span>SHASUMS256.txt.asc<span class="w"> </span>SHASUMS256.txt<span class="w"> </span><span class="se">\</span>
</span><span id="__span-126-9"><a id="__codelineno-126-9" name="__codelineno-126-9" href="#__codelineno-126-9"></a><span class="w">  </span><span class="o">&amp;&amp;</span><span class="w"> </span>ln<span class="w"> </span>-s<span class="w"> </span>/usr/local/bin/node<span class="w"> </span>/usr/local/bin/nodejs
</span></code></pre></div> <p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，Dockerfile 构建维护变得更轻松了。</p> <p>下列指令可以支持环境变量： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。</p> <p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。</p> <h4 id="726arg">7.2.6、ARG<a class="headerlink" href="#726arg" title="锚点链接">¶</a></h4> <p><code>ARG</code> 构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p> <p>格式为：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-127-1"><a id="__codelineno-127-1" name="__codelineno-127-1" href="#__codelineno-127-1"></a><span class="k">ARG</span><span class="w"> </span>&lt;参数名&gt;<span class="o">[=</span>&lt;默认值&gt;<span class="o">]</span>
</span></code></pre></div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Dockerfile 中的 <code>ARG</code> 指令是定义参数名称以及其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p> </div> <p>灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。</p> <p>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-128-1"><a id="__codelineno-128-1" name="__codelineno-128-1" href="#__codelineno-128-1"></a><span class="k">ARG</span><span class="w"> </span><span class="nv">DOCKER_USERNAME</span><span class="o">=</span>library
</span><span id="__span-128-2"><a id="__codelineno-128-2" name="__codelineno-128-2" href="#__codelineno-128-2"></a>
</span><span id="__span-128-3"><a id="__codelineno-128-3" name="__codelineno-128-3" href="#__codelineno-128-3"></a><span class="k">FROM</span><span class="w"> </span><span class="s">${DOCKER_USERNAME}/alpine</span>
</span><span id="__span-128-4"><a id="__codelineno-128-4" name="__codelineno-128-4" href="#__codelineno-128-4"></a>
</span><span id="__span-128-5"><a id="__codelineno-128-5" name="__codelineno-128-5" href="#__codelineno-128-5"></a><span class="k">RUN</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>-x<span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="si">${</span><span class="nv">DOCKER_USERNAME</span><span class="si">}</span>
</span></code></pre></div> <p>使用上述 Dockerfile 会发现无法输出 <code>${DOCKER_USERNAME}</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code></p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-129-1"><a id="__codelineno-129-1" name="__codelineno-129-1" href="#__codelineno-129-1"></a><span class="c">## 只在 FROM 中生效</span>
</span><span id="__span-129-2"><a id="__codelineno-129-2" name="__codelineno-129-2" href="#__codelineno-129-2"></a><span class="k">ARG</span><span class="w"> </span><span class="nv">DOCKER_USERNAME</span><span class="o">=</span>library
</span><span id="__span-129-3"><a id="__codelineno-129-3" name="__codelineno-129-3" href="#__codelineno-129-3"></a>
</span><span id="__span-129-4"><a id="__codelineno-129-4" name="__codelineno-129-4" href="#__codelineno-129-4"></a><span class="k">FROM</span><span class="w"> </span><span class="s">${DOCKER_USERNAME}/alpine</span>
</span><span id="__span-129-5"><a id="__codelineno-129-5" name="__codelineno-129-5" href="#__codelineno-129-5"></a>
</span><span id="__span-129-6"><a id="__codelineno-129-6" name="__codelineno-129-6" href="#__codelineno-129-6"></a><span class="c">## 要想在 FROM 之后使用，必须再次指定</span>
</span><span id="__span-129-7"><a id="__codelineno-129-7" name="__codelineno-129-7" href="#__codelineno-129-7"></a><span class="k">ARG</span><span class="w"> </span><span class="nv">DOCKER_USERNAME</span><span class="o">=</span>library
</span><span id="__span-129-8"><a id="__codelineno-129-8" name="__codelineno-129-8" href="#__codelineno-129-8"></a>
</span><span id="__span-129-9"><a id="__codelineno-129-9" name="__codelineno-129-9" href="#__codelineno-129-9"></a><span class="k">RUN</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>-x<span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="si">${</span><span class="nv">DOCKER_USERNAME</span><span class="si">}</span>
</span></code></pre></div> <p>对于多阶段构建，尤其要注意这个问题：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-130-1"><a id="__codelineno-130-1" name="__codelineno-130-1" href="#__codelineno-130-1"></a><span class="c">## 这个变量在每个 FROM 中都生效</span>
</span><span id="__span-130-2"><a id="__codelineno-130-2" name="__codelineno-130-2" href="#__codelineno-130-2"></a><span class="k">ARG</span><span class="w"> </span><span class="nv">DOCKER_USERNAME</span><span class="o">=</span>library
</span><span id="__span-130-3"><a id="__codelineno-130-3" name="__codelineno-130-3" href="#__codelineno-130-3"></a>
</span><span id="__span-130-4"><a id="__codelineno-130-4" name="__codelineno-130-4" href="#__codelineno-130-4"></a><span class="k">FROM</span><span class="w"> </span><span class="s">${DOCKER_USERNAME}/alpine</span>
</span><span id="__span-130-5"><a id="__codelineno-130-5" name="__codelineno-130-5" href="#__codelineno-130-5"></a>
</span><span id="__span-130-6"><a id="__codelineno-130-6" name="__codelineno-130-6" href="#__codelineno-130-6"></a><span class="k">RUN</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>-x<span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="m">1</span>
</span><span id="__span-130-7"><a id="__codelineno-130-7" name="__codelineno-130-7" href="#__codelineno-130-7"></a>
</span><span id="__span-130-8"><a id="__codelineno-130-8" name="__codelineno-130-8" href="#__codelineno-130-8"></a><span class="k">FROM</span><span class="w"> </span><span class="s">${DOCKER_USERNAME}/alpine</span>
</span><span id="__span-130-9"><a id="__codelineno-130-9" name="__codelineno-130-9" href="#__codelineno-130-9"></a>
</span><span id="__span-130-10"><a id="__codelineno-130-10" name="__codelineno-130-10" href="#__codelineno-130-10"></a><span class="k">RUN</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>-x<span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="m">2</span>
</span></code></pre></div> <p>对于上述 Dockerfile 两个 <code>FROM</code> 指令都可以使用 <code>${DOCKER_USERNAME}</code>，对于在各个阶段中使用的变量都必须在每个阶段分别指定：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-131-1"><a id="__codelineno-131-1" name="__codelineno-131-1" href="#__codelineno-131-1"></a><span class="k">ARG</span><span class="w"> </span><span class="nv">DOCKER_USERNAME</span><span class="o">=</span>library
</span><span id="__span-131-2"><a id="__codelineno-131-2" name="__codelineno-131-2" href="#__codelineno-131-2"></a>
</span><span id="__span-131-3"><a id="__codelineno-131-3" name="__codelineno-131-3" href="#__codelineno-131-3"></a><span class="k">FROM</span><span class="w"> </span><span class="s">${DOCKER_USERNAME}/alpine</span>
</span><span id="__span-131-4"><a id="__codelineno-131-4" name="__codelineno-131-4" href="#__codelineno-131-4"></a>
</span><span id="__span-131-5"><a id="__codelineno-131-5" name="__codelineno-131-5" href="#__codelineno-131-5"></a><span class="c">## 在FROM 之后使用变量，必须在每个阶段分别指定</span>
</span><span id="__span-131-6"><a id="__codelineno-131-6" name="__codelineno-131-6" href="#__codelineno-131-6"></a><span class="k">ARG</span><span class="w"> </span><span class="nv">DOCKER_USERNAME</span><span class="o">=</span>library
</span><span id="__span-131-7"><a id="__codelineno-131-7" name="__codelineno-131-7" href="#__codelineno-131-7"></a>
</span><span id="__span-131-8"><a id="__codelineno-131-8" name="__codelineno-131-8" href="#__codelineno-131-8"></a><span class="k">RUN</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>-x<span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="si">${</span><span class="nv">DOCKER_USERNAME</span><span class="si">}</span>
</span><span id="__span-131-9"><a id="__codelineno-131-9" name="__codelineno-131-9" href="#__codelineno-131-9"></a>
</span><span id="__span-131-10"><a id="__codelineno-131-10" name="__codelineno-131-10" href="#__codelineno-131-10"></a><span class="k">FROM</span><span class="w"> </span><span class="s">${DOCKER_USERNAME}/alpine</span>
</span><span id="__span-131-11"><a id="__codelineno-131-11" name="__codelineno-131-11" href="#__codelineno-131-11"></a>
</span><span id="__span-131-12"><a id="__codelineno-131-12" name="__codelineno-131-12" href="#__codelineno-131-12"></a><span class="c">## 在FROM 之后使用变量，必须在每个阶段分别指定</span>
</span><span id="__span-131-13"><a id="__codelineno-131-13" name="__codelineno-131-13" href="#__codelineno-131-13"></a><span class="k">ARG</span><span class="w"> </span><span class="nv">DOCKER_USERNAME</span><span class="o">=</span>library
</span><span id="__span-131-14"><a id="__codelineno-131-14" name="__codelineno-131-14" href="#__codelineno-131-14"></a>
</span><span id="__span-131-15"><a id="__codelineno-131-15" name="__codelineno-131-15" href="#__codelineno-131-15"></a><span class="k">RUN</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span>-x<span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="si">${</span><span class="nv">DOCKER_USERNAME</span><span class="si">}</span>
</span></code></pre></div> <h4 id="727volume">7.2.7、VOLUME<a class="headerlink" href="#727volume" title="锚点链接">¶</a></h4> <p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷（volume）中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中可以使用 <code>VOLUME</code> 指令事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p> <p>格式有两种：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-132-1"><a id="__codelineno-132-1" name="__codelineno-132-1" href="#__codelineno-132-1"></a><span class="k">VOLUME</span><span class="w"> </span><span class="p">[</span><span class="s2">"&lt;路径1&gt;"</span><span class="p">,</span><span class="w"> </span><span class="s2">"&lt;路径2&gt;"</span><span class="err">...</span><span class="p">]</span>
</span><span id="__span-132-2"><a id="__codelineno-132-2" name="__codelineno-132-2" href="#__codelineno-132-2"></a><span class="k">VOLUME</span><span class="w"> </span><span class="s">&lt;路径&gt;</span>
</span></code></pre></div> <p>下面是个简单的示例：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-133-1"><a id="__codelineno-133-1" name="__codelineno-133-1" href="#__codelineno-133-1"></a><span class="k">VOLUME</span><span class="w"> </span><span class="s">/data</span>
</span></code></pre></div> <p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-134-1"><a id="__codelineno-134-1" name="__codelineno-134-1" href="#__codelineno-134-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>-v<span class="w"> </span>mydata:/data<span class="w"> </span>xxxx
</span></code></pre></div> <p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p> <h4 id="728expose">7.2.8、EXPOSE<a class="headerlink" href="#728expose" title="锚点链接">¶</a></h4> <p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p> <p>格式为： </p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-135-1"><a id="__codelineno-135-1" name="__codelineno-135-1" href="#__codelineno-135-1"></a><span class="k">EXPOSE</span><span class="w"> </span><span class="s">&lt;端口1&gt; [&lt;端口2&gt;...]</span>
</span></code></pre></div> <p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code> 是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p> <h4 id="729workdir">7.2.9、WORKDIR<a class="headerlink" href="#729workdir" title="锚点链接">¶</a></h4> <p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p> <p>格式为：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-136-1"><a id="__codelineno-136-1" name="__codelineno-136-1" href="#__codelineno-136-1"></a><span class="k">WORKDIR</span><span class="w"> </span><span class="s">&lt;工作目录路径&gt;</span>
</span></code></pre></div> <p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-137-1"><a id="__codelineno-137-1" name="__codelineno-137-1" href="#__codelineno-137-1"></a><span class="k">RUN</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>/app
</span><span id="__span-137-2"><a id="__codelineno-137-2" name="__codelineno-137-2" href="#__codelineno-137-2"></a><span class="k">RUN</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">"hello"</span><span class="w"> </span>&gt;<span class="w"> </span>world.txt
</span></code></pre></div> <p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。</p> <p>每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p> <p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-138-1"><a id="__codelineno-138-1" name="__codelineno-138-1" href="#__codelineno-138-1"></a><span class="k">WORKDIR</span><span class="w"> </span><span class="s">/app</span>
</span><span id="__span-138-2"><a id="__codelineno-138-2" name="__codelineno-138-2" href="#__codelineno-138-2"></a>
</span><span id="__span-138-3"><a id="__codelineno-138-3" name="__codelineno-138-3" href="#__codelineno-138-3"></a><span class="k">RUN</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">"hello"</span><span class="w"> </span>&gt;<span class="w"> </span>world.txt
</span></code></pre></div> <p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-139-1"><a id="__codelineno-139-1" name="__codelineno-139-1" href="#__codelineno-139-1"></a><span class="k">WORKDIR</span><span class="w"> </span><span class="s">/a</span>
</span><span id="__span-139-2"><a id="__codelineno-139-2" name="__codelineno-139-2" href="#__codelineno-139-2"></a><span class="k">WORKDIR</span><span class="w"> </span><span class="s">b</span>
</span><span id="__span-139-3"><a id="__codelineno-139-3" name="__codelineno-139-3" href="#__codelineno-139-3"></a><span class="k">WORKDIR</span><span class="w"> </span><span class="s">c</span>
</span><span id="__span-139-4"><a id="__codelineno-139-4" name="__codelineno-139-4" href="#__codelineno-139-4"></a>
</span><span id="__span-139-5"><a id="__codelineno-139-5" name="__codelineno-139-5" href="#__codelineno-139-5"></a><span class="k">RUN</span><span class="w"> </span>pwd
</span></code></pre></div> <p><code>RUN pwd</code> 的工作目录为 <code>/a/b/c</code>。</p> <h4 id="7210user">7.2.10、USER<a class="headerlink" href="#7210user" title="锚点链接">¶</a></h4> <p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>、<code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p> <p>格式为：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-140-1"><a id="__codelineno-140-1" name="__codelineno-140-1" href="#__codelineno-140-1"></a><span class="k">USER</span><span class="w"> </span><span class="s">&lt;用户名&gt;[:&lt;用户组&gt;]</span>
</span></code></pre></div> <p>注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-141-1"><a id="__codelineno-141-1" name="__codelineno-141-1" href="#__codelineno-141-1"></a><span class="k">RUN</span><span class="w"> </span>groupadd<span class="w"> </span>-r<span class="w"> </span>redis<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>useradd<span class="w"> </span>-r<span class="w"> </span>-g<span class="w"> </span>redis<span class="w"> </span>redis
</span><span id="__span-141-2"><a id="__codelineno-141-2" name="__codelineno-141-2" href="#__codelineno-141-2"></a><span class="k">USER</span><span class="w"> </span><span class="s">redis</span>
</span><span id="__span-141-3"><a id="__codelineno-141-3" name="__codelineno-141-3" href="#__codelineno-141-3"></a><span class="k">RUN</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">"redis-server"</span><span class="w"> </span><span class="o">]</span>
</span></code></pre></div> <p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href="https://github.com/tianon/gosu"><code>gosu</code></a>：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-142-1"><a id="__codelineno-142-1" name="__codelineno-142-1" href="#__codelineno-142-1"></a><span class="c">## 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span>
</span><span id="__span-142-2"><a id="__codelineno-142-2" name="__codelineno-142-2" href="#__codelineno-142-2"></a><span class="k">RUN</span><span class="w"> </span>groupadd<span class="w"> </span>-r<span class="w"> </span>redis<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>useradd<span class="w"> </span>-r<span class="w"> </span>-g<span class="w"> </span>redis<span class="w"> </span>redis
</span><span id="__span-142-3"><a id="__codelineno-142-3" name="__codelineno-142-3" href="#__codelineno-142-3"></a><span class="c">## 下载 gosu</span>
</span><span id="__span-142-4"><a id="__codelineno-142-4" name="__codelineno-142-4" href="#__codelineno-142-4"></a><span class="k">RUN</span><span class="w"> </span>wget<span class="w"> </span>-O<span class="w"> </span>/usr/local/bin/gosu<span class="w"> </span><span class="s2">"https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64"</span><span class="w"> </span><span class="se">\</span>
</span><span id="__span-142-5"><a id="__codelineno-142-5" name="__codelineno-142-5" href="#__codelineno-142-5"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>chmod<span class="w"> </span>+x<span class="w"> </span>/usr/local/bin/gosu<span class="w"> </span><span class="se">\</span>
</span><span id="__span-142-6"><a id="__codelineno-142-6" name="__codelineno-142-6" href="#__codelineno-142-6"></a><span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>gosu<span class="w"> </span>nobody<span class="w"> </span>true
</span><span id="__span-142-7"><a id="__codelineno-142-7" name="__codelineno-142-7" href="#__codelineno-142-7"></a><span class="c">## 设置 CMD，并以另外的用户执行</span>
</span><span id="__span-142-8"><a id="__codelineno-142-8" name="__codelineno-142-8" href="#__codelineno-142-8"></a><span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">"exec"</span><span class="p">,</span><span class="w"> </span><span class="s2">"gosu"</span><span class="p">,</span><span class="w"> </span><span class="s2">"redis"</span><span class="p">,</span><span class="w"> </span><span class="s2">"redis-server"</span><span class="w"> </span><span class="p">]</span>
</span></code></pre></div> <h4 id="7211healthcheck">7.2.11、HEALTHCHECK<a class="headerlink" href="#7211healthcheck" title="锚点链接">¶</a></h4> <p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p> <p>格式有两种：</p> <ul> <li> <p>设置检查容器健康状况的命令：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-143-1"><a id="__codelineno-143-1" name="__codelineno-143-1" href="#__codelineno-143-1"></a><span class="k">HEALTHCHECK</span><span class="w"> </span><span class="o">[</span>选项<span class="o">]</span><span class="w"> </span>CMD<span class="w"> </span>&lt;命令&gt;
</span></code></pre></div> </li> <li> <p>如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-144-1"><a id="__codelineno-144-1" name="__codelineno-144-1" href="#__codelineno-144-1"></a><span class="k">HEALTHCHECK</span><span class="w"> </span>NONE
</span></code></pre></div> </li> </ul> <p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p> <p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p> <p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p> <p><code>HEALTHCHECK</code> 支持下列选项：</p> <ul> <li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒。</li> <li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒。</li> <li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li> </ul> <p>和 <code>CMD</code>、<code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p> <p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：</p> <ul> <li><code>0</code>：成功。</li> <li><code>1</code>：失败。</li> <li><code>2</code>：保留，不要使用这个值。</li> </ul> <p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 Dockerfile 的 <code>HEALTHCHECK</code> 可以这么写：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-145-1"><a id="__codelineno-145-1" name="__codelineno-145-1" href="#__codelineno-145-1"></a><span class="k">FROM</span><span class="w"> </span><span class="s">nginx</span>
</span><span id="__span-145-2"><a id="__codelineno-145-2" name="__codelineno-145-2" href="#__codelineno-145-2"></a><span class="k">RUN</span><span class="w"> </span>apt-get<span class="w"> </span>update<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>-y<span class="w"> </span>curl<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>rm<span class="w"> </span>-rf<span class="w"> </span>/var/lib/apt/lists/*
</span><span id="__span-145-3"><a id="__codelineno-145-3" name="__codelineno-145-3" href="#__codelineno-145-3"></a><span class="k">HEALTHCHECK</span><span class="w"> </span>--interval<span class="o">=</span>5s<span class="w"> </span>--timeout<span class="o">=</span>3s<span class="w"> </span><span class="se">\</span>
</span><span id="__span-145-4"><a id="__codelineno-145-4" name="__codelineno-145-4" href="#__codelineno-145-4"></a><span class="w">  </span><span class="k">CMD</span><span class="w"> </span>curl<span class="w"> </span>-fs<span class="w"> </span>http://localhost/<span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">exit</span><span class="w"> </span><span class="m">1</span>
</span></code></pre></div> <p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p> <p>使用 <code>docker build</code> 来构建这个镜像：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-146-1"><a id="__codelineno-146-1" name="__codelineno-146-1" href="#__codelineno-146-1"></a>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>myweb:v1<span class="w"> </span>.
</span></code></pre></div> <p>构建好了后，我们启动一个容器：</p> <div class="language-shell highlight"><span class="filename">Bash</span><pre><span></span><code><span id="__span-147-1"><a id="__codelineno-147-1" name="__codelineno-147-1" href="#__codelineno-147-1"></a>docker<span class="w"> </span>run<span class="w"> </span>-d<span class="w"> </span>--name<span class="w"> </span>web<span class="w"> </span>-p<span class="w"> </span><span class="m">80</span>:80<span class="w"> </span>myweb:v1
</span></code></pre></div> <p>当运行该镜像后，可以通过 <code>docker ps</code> 看到最初的状态为 <code>(health: starting)</code>：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-148-1"><a id="__codelineno-148-1" name="__codelineno-148-1" href="#__codelineno-148-1"></a>$ docker ps
</span><span id="__span-148-2"><a id="__codelineno-148-2" name="__codelineno-148-2" href="#__codelineno-148-2"></a>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES
</span><span id="__span-148-3"><a id="__codelineno-148-3" name="__codelineno-148-3" href="#__codelineno-148-3"></a>03e28eb00bd0        myweb:v1            "nginx -g 'daemon off"   3 seconds ago       Up 2 seconds (health: starting)   80/tcp, 443/tcp     web
</span></code></pre></div> <p>在等待几秒钟后，再次 <code>docker ps</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-149-1"><a id="__codelineno-149-1" name="__codelineno-149-1" href="#__codelineno-149-1"></a>$ docker ps
</span><span id="__span-149-2"><a id="__codelineno-149-2" name="__codelineno-149-2" href="#__codelineno-149-2"></a>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES
</span><span id="__span-149-3"><a id="__codelineno-149-3" name="__codelineno-149-3" href="#__codelineno-149-3"></a>03e28eb00bd0        myweb:v1            "nginx -g 'daemon off"   18 seconds ago      Up 16 seconds (healthy)   80/tcp, 443/tcp     web
</span></code></pre></div> <p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code>。</p> <p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看：</p> <div class="language-text highlight"><span class="filename">Text Only</span><pre><span></span><code><span id="__span-150-1"><a id="__codelineno-150-1" name="__codelineno-150-1" href="#__codelineno-150-1"></a>$ docker inspect --format '{{json .State.Health}}' web | python -m json.tool
</span><span id="__span-150-2"><a id="__codelineno-150-2" name="__codelineno-150-2" href="#__codelineno-150-2"></a>{
</span><span id="__span-150-3"><a id="__codelineno-150-3" name="__codelineno-150-3" href="#__codelineno-150-3"></a>    "FailingStreak": 0,
</span><span id="__span-150-4"><a id="__codelineno-150-4" name="__codelineno-150-4" href="#__codelineno-150-4"></a>    "Log": [
</span><span id="__span-150-5"><a id="__codelineno-150-5" name="__codelineno-150-5" href="#__codelineno-150-5"></a>        {
</span><span id="__span-150-6"><a id="__codelineno-150-6" name="__codelineno-150-6" href="#__codelineno-150-6"></a>            "End": "2016-11-25T14:35:37.940957051Z",
</span><span id="__span-150-7"><a id="__codelineno-150-7" name="__codelineno-150-7" href="#__codelineno-150-7"></a>            "ExitCode": 0,
</span><span id="__span-150-8"><a id="__codelineno-150-8" name="__codelineno-150-8" href="#__codelineno-150-8"></a>            "Output": "&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n",
</span><span id="__span-150-9"><a id="__codelineno-150-9" name="__codelineno-150-9" href="#__codelineno-150-9"></a>            "Start": "2016-11-25T14:35:37.780192565Z"
</span><span id="__span-150-10"><a id="__codelineno-150-10" name="__codelineno-150-10" href="#__codelineno-150-10"></a>        }
</span><span id="__span-150-11"><a id="__codelineno-150-11" name="__codelineno-150-11" href="#__codelineno-150-11"></a>    ],
</span><span id="__span-150-12"><a id="__codelineno-150-12" name="__codelineno-150-12" href="#__codelineno-150-12"></a>    "Status": "healthy"
</span><span id="__span-150-13"><a id="__codelineno-150-13" name="__codelineno-150-13" href="#__codelineno-150-13"></a>}
</span></code></pre></div> <h4 id="7212onbuild">7.2.12、ONBUILD<a class="headerlink" href="#7212onbuild" title="锚点链接">¶</a></h4> <p><code>ONBUILD</code> 是 Dockerfile 中的一个特殊指令，它后面跟的是其它指令，比如 <code>RUN</code>、<code>COPY</code> 等，用于为子镜像设置触发器（trigger），即：当以当前镜像为基础构建另一个镜像时，<code>ONBUILD</code> 中的指令才会执行。</p> <p>格式为：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-151-1"><a id="__codelineno-151-1" name="__codelineno-151-1" href="#__codelineno-151-1"></a><span class="k">ONBUILD</span><span class="w"> </span>&lt;其它指令&gt;
</span></code></pre></div> <p>Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p> <p><strong>为多项目创建统一的构建模板</strong></p> <p>假设你有多个项目，它们的构建步骤类似，比如：</p> <ul> <li>把源码复制进去</li> <li>安装依赖</li> <li>编译或打包</li> </ul> <p>你可以做一个统一的基础镜像，比如 Java 项目打包镜像：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-152-1"><a id="__codelineno-152-1" name="__codelineno-152-1" href="#__codelineno-152-1"></a><span class="c">## Dockerfile for base image</span>
</span><span id="__span-152-2"><a id="__codelineno-152-2" name="__codelineno-152-2" href="#__codelineno-152-2"></a><span class="k">FROM</span><span class="w"> </span><span class="s">maven:3.8.6-openjdk-17</span>
</span><span id="__span-152-3"><a id="__codelineno-152-3" name="__codelineno-152-3" href="#__codelineno-152-3"></a>
</span><span id="__span-152-4"><a id="__codelineno-152-4" name="__codelineno-152-4" href="#__codelineno-152-4"></a><span class="c">## 设置触发器：当别人 FROM 这个镜像时会执行下面指令</span>
</span><span id="__span-152-5"><a id="__codelineno-152-5" name="__codelineno-152-5" href="#__codelineno-152-5"></a><span class="k">ONBUILD</span><span class="w"> </span><span class="k">COPY</span><span class="w"> </span>.<span class="w"> </span>/app
</span><span id="__span-152-6"><a id="__codelineno-152-6" name="__codelineno-152-6" href="#__codelineno-152-6"></a><span class="k">ONBUILD</span><span class="w"> </span><span class="k">WORKDIR</span><span class="w"> </span><span class="s">/app</span>
</span><span id="__span-152-7"><a id="__codelineno-152-7" name="__codelineno-152-7" href="#__codelineno-152-7"></a><span class="k">ONBUILD</span><span class="w"> </span><span class="k">RUN</span><span class="w"> </span>mvn<span class="w"> </span>clean<span class="w"> </span>package
</span></code></pre></div> <p>然后你在项目中用这个镜像：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-153-1"><a id="__codelineno-153-1" name="__codelineno-153-1" href="#__codelineno-153-1"></a><span class="c">## Project-specific Dockerfile</span>
</span><span id="__span-153-2"><a id="__codelineno-153-2" name="__codelineno-153-2" href="#__codelineno-153-2"></a><span class="k">FROM</span><span class="w"> </span><span class="s">yourcompany/maven-base:latest</span>
</span><span id="__span-153-3"><a id="__codelineno-153-3" name="__codelineno-153-3" href="#__codelineno-153-3"></a><span class="c">## 不需要再写 COPY 和 RUN，ONBUILD 会自动执行</span>
</span></code></pre></div> <p><strong>公司统一构建规范</strong></p> <p>当公司有统一构建策略，例如 Node.js 应用都需要运行 ESLint 和测试，你可以创建这样的基础镜像：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-154-1"><a id="__codelineno-154-1" name="__codelineno-154-1" href="#__codelineno-154-1"></a><span class="k">FROM</span><span class="w"> </span><span class="s">node:20</span>
</span><span id="__span-154-2"><a id="__codelineno-154-2" name="__codelineno-154-2" href="#__codelineno-154-2"></a>
</span><span id="__span-154-3"><a id="__codelineno-154-3" name="__codelineno-154-3" href="#__codelineno-154-3"></a><span class="k">ONBUILD</span><span class="w"> </span><span class="k">COPY</span><span class="w"> </span>.<span class="w"> </span>/app
</span><span id="__span-154-4"><a id="__codelineno-154-4" name="__codelineno-154-4" href="#__codelineno-154-4"></a><span class="k">ONBUILD</span><span class="w"> </span><span class="k">WORKDIR</span><span class="w"> </span><span class="s">/app</span>
</span><span id="__span-154-5"><a id="__codelineno-154-5" name="__codelineno-154-5" href="#__codelineno-154-5"></a><span class="k">ONBUILD</span><span class="w"> </span><span class="k">RUN</span><span class="w"> </span>npm<span class="w"> </span>install
</span><span id="__span-154-6"><a id="__codelineno-154-6" name="__codelineno-154-6" href="#__codelineno-154-6"></a><span class="k">ONBUILD</span><span class="w"> </span><span class="k">RUN</span><span class="w"> </span>npm<span class="w"> </span>run<span class="w"> </span>lint
</span><span id="__span-154-7"><a id="__codelineno-154-7" name="__codelineno-154-7" href="#__codelineno-154-7"></a><span class="k">ONBUILD</span><span class="w"> </span><span class="k">RUN</span><span class="w"> </span>npm<span class="w"> </span>test
</span></code></pre></div> <h4 id="7213label">7.2.13、LABEL<a class="headerlink" href="#7213label" title="锚点链接">¶</a></h4> <p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-155-1"><a id="__codelineno-155-1" name="__codelineno-155-1" href="#__codelineno-155-1"></a><span class="k">LABEL</span><span class="w"> </span>&lt;key&gt;<span class="o">=</span>&lt;value&gt;<span class="w"> </span>&lt;key&gt;<span class="o">=</span>&lt;value&gt;<span class="w"> </span>&lt;key&gt;<span class="o">=</span>&lt;value&gt;<span class="w"> </span>...
</span></code></pre></div> <p>我们还可以用一些标签来申明镜像的作者、文档地址等：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-156-1"><a id="__codelineno-156-1" name="__codelineno-156-1" href="#__codelineno-156-1"></a><span class="k">LABEL</span><span class="w"> </span>org.opencontainers.image.authors<span class="o">=</span><span class="s2">"yeasy"</span>
</span><span id="__span-156-2"><a id="__codelineno-156-2" name="__codelineno-156-2" href="#__codelineno-156-2"></a>
</span><span id="__span-156-3"><a id="__codelineno-156-3" name="__codelineno-156-3" href="#__codelineno-156-3"></a><span class="k">LABEL</span><span class="w"> </span>org.opencontainers.image.documentation<span class="o">=</span><span class="s2">"https://yeasy.gitbooks.io"</span>
</span></code></pre></div> <p>具体可以参考 https://github.com/opencontainers/image-spec/blob/master/annotations.md</p> <h4 id="7214shell">7.2.14、SHELL<a class="headerlink" href="#7214shell" title="锚点链接">¶</a></h4> <p><code>SHELL</code> 指令可以指定 <code>RUN</code>、<code>ENTRYPOINT</code> 和 <code>CMD</code> 指令的 shell，Linux 中默认为 <code>["/bin/sh", "-c"]</code>。</p> <p>格式为：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-157-1"><a id="__codelineno-157-1" name="__codelineno-157-1" href="#__codelineno-157-1"></a><span class="k">SHELL</span><span class="w"> </span><span class="p">[</span><span class="s2">"executable"</span><span class="p">,</span><span class="w"> </span><span class="s2">"parameters"</span><span class="p">]</span>
</span></code></pre></div> <p>两个 <code>RUN</code> 运行同一命令，第二个 <code>RUN</code> 运行的命令会打印出每条命令并当遇到错误时退出：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-158-1"><a id="__codelineno-158-1" name="__codelineno-158-1" href="#__codelineno-158-1"></a><span class="k">SHELL</span><span class="w"> </span><span class="p">[</span><span class="s2">"/bin/sh"</span><span class="p">,</span><span class="w"> </span><span class="s2">"-c"</span><span class="p">]</span>
</span><span id="__span-158-2"><a id="__codelineno-158-2" name="__codelineno-158-2" href="#__codelineno-158-2"></a>
</span><span id="__span-158-3"><a id="__codelineno-158-3" name="__codelineno-158-3" href="#__codelineno-158-3"></a><span class="k">RUN</span><span class="w"> </span>lll<span class="w"> </span><span class="p">;</span><span class="w"> </span>ls
</span><span id="__span-158-4"><a id="__codelineno-158-4" name="__codelineno-158-4" href="#__codelineno-158-4"></a>
</span><span id="__span-158-5"><a id="__codelineno-158-5" name="__codelineno-158-5" href="#__codelineno-158-5"></a><span class="k">SHELL</span><span class="w"> </span><span class="p">[</span><span class="s2">"/bin/sh"</span><span class="p">,</span><span class="w"> </span><span class="s2">"-cex"</span><span class="p">]</span>
</span><span id="__span-158-6"><a id="__codelineno-158-6" name="__codelineno-158-6" href="#__codelineno-158-6"></a>
</span><span id="__span-158-7"><a id="__codelineno-158-7" name="__codelineno-158-7" href="#__codelineno-158-7"></a><span class="k">RUN</span><span class="w"> </span>lll<span class="w"> </span><span class="p">;</span><span class="w"> </span>ls
</span></code></pre></div> <p>当 <code>ENTRYPOINT</code>、<code>CMD</code> 以 shell 格式指定时，<code>SHELL</code> 指令所指定的 shell 也会成为这两个指令的 shell：</p> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-159-1"><a id="__codelineno-159-1" name="__codelineno-159-1" href="#__codelineno-159-1"></a><span class="k">SHELL</span><span class="w"> </span><span class="p">[</span><span class="s2">"/bin/sh"</span><span class="p">,</span><span class="w"> </span><span class="s2">"-cex"</span><span class="p">]</span>
</span><span id="__span-159-2"><a id="__codelineno-159-2" name="__codelineno-159-2" href="#__codelineno-159-2"></a>
</span><span id="__span-159-3"><a id="__codelineno-159-3" name="__codelineno-159-3" href="#__codelineno-159-3"></a><span class="c">## /bin/sh -cex "nginx"</span>
</span><span id="__span-159-4"><a id="__codelineno-159-4" name="__codelineno-159-4" href="#__codelineno-159-4"></a><span class="k">ENTRYPOINT</span><span class="w"> </span>nginx
</span></code></pre></div> <div class="language-dockerfile highlight"><span class="filename">Docker</span><pre><span></span><code><span id="__span-160-1"><a id="__codelineno-160-1" name="__codelineno-160-1" href="#__codelineno-160-1"></a><span class="k">SHELL</span><span class="w"> </span><span class="p">[</span><span class="s2">"/bin/sh"</span><span class="p">,</span><span class="w"> </span><span class="s2">"-cex"</span><span class="p">]</span>
</span><span id="__span-160-2"><a id="__codelineno-160-2" name="__codelineno-160-2" href="#__codelineno-160-2"></a>
</span><span id="__span-160-3"><a id="__codelineno-160-3" name="__codelineno-160-3" href="#__codelineno-160-3"></a><span class="c">## /bin/sh -cex "nginx"</span>
</span><span id="__span-160-4"><a id="__codelineno-160-4" name="__codelineno-160-4" href="#__codelineno-160-4"></a><span class="k">CMD</span><span class="w"> </span>nginx
</span></code></pre></div> <h3 id="73docker-buildx">7.3、Docker Buildx<a class="headerlink" href="#73docker-buildx" title="锚点链接">¶</a></h3> <p>Docker Buildx 是一个 Docker CLI 插件，其扩展了 Docker 命令，支持 <a href="https://yeasy.gitbook.io/docker_practice/buildx/buildkit">Moby BuildKit</a> 提供的功能。提供了与 <code>docker build</code> 相同的用户体验，并增加了许多新功能。</p> <div class="admonition tip"> <p class="admonition-title">Important</p> <p>该功能仅适用于 Docker v19.03+ 版本。</p> </div> <aside class="md-source-file"> <span class="md-source-file__fact"> <span class="md-icon" title="最后更新"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"></path></svg> </span> <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="2026年1月22日 20:21:58 UTC">2026年1月22日 20:21:58</span> </span> <span class="md-source-file__fact"> <span class="md-icon" title="创建日期"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"></path></svg> </span> <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="2024年9月15日 18:47:26 UTC">2024年9月15日 18:47:26</span> </span> </aside> </article> </div> <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type="button" class="md-top md-icon" data-md-component="top" hidden> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"></path></svg> 回到页面顶部 </button> </main> <footer class="md-footer"> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class="md-copyright"> Made with <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener"> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class="md-dialog" data-md-component="dialog"> <div class="md-dialog__inner md-typeset"></div> </div> <script id="__config" type="application/json">{"annotate": null, "base": "..", "features": ["navigation.top", "navigation.indexes", "navigation.tracking", "navigation.instant", "navigation.path", "content.tabs.link", "content.code.copy"], "search": "../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script> <script src="../assets/javascripts/bundle.79ae519e.min.js"></script> <script src="../_javascripts/auto_title.js"></script>  <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(()=>{ lightbox.reload(); });
</script></body></html>